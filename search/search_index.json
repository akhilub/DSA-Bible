{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DSA-Bible","text":"<p>Welcome to my collection of DSA problems solutions!</p> <p>This site contains detailed explanations and implementations of various algorithms through LeetCode problems.</p> Akhil Singh Chauhan                          Author"},{"location":"#problem-categories","title":"Problem Categories","text":"<p>Grind 169</p> <p>Array</p> <p>Backtracking</p> <p>Binary Search</p> <p>Binary Search Tree</p> <p>Binary Tree</p> <p>Breadth-First Search</p> <p>Data Stream</p> <p>Design</p> <p>Dynamic Programming</p> <p>Greedy</p> <p>Hash Table</p> <p>Heap (Priority Queue)</p> <p>Interactive</p> <p>LP</p> <p>Linked List</p> <p>MIP</p> <p>Math</p> <p>Matrix</p> <p>Monotonic Stack</p> <p>Recursion</p> <p>Sliding Window</p> <p>Stack</p> <p>String</p> <p>Tree</p> <p>Trie</p> <p>Two Pointers</p> <p>For a complete list of problem categories, see the Topics page.</p>"},{"location":"#latest-releases-updates-solutions","title":"Latest Releases, Updates, Solutions","text":""},{"location":"#to-do","title":"To Do","text":"<ul> <li>Login &amp; SignUp icons on Mobile &amp; Ipads</li> <li>Checkout Page Figure our Payments</li> </ul>"},{"location":"#may-22-2025","title":"May 22, 2025","text":"<ul> <li>Privacy Policy page</li> </ul>"},{"location":"#may-21-2025","title":"May 21, 2025","text":"<ul> <li>Custom Author Data Logic via meta tags</li> </ul>"},{"location":"#may-20-2025","title":"May 20, 2025","text":"<ul> <li>Added Debouncing, Event-Listeners</li> </ul>"},{"location":"#may-19-2025","title":"May 19, 2025","text":"<ul> <li>Fast Loading Pages</li> <li>Removed Lag on problems pages.</li> </ul>"},{"location":"#may-18-2025","title":"May 18, 2025","text":"<ul> <li>Login SignUp Card to protect content from unauthorized access on all pages</li> </ul>"},{"location":"#may-17-2025","title":"May 17, 2025","text":"<ul> <li>Pricing Card</li> </ul>"},{"location":"#may-16-2025","title":"May 16, 2025","text":"<ul> <li>Connected Auth0 with Stripe in Actions</li> </ul>"},{"location":"#may-15-2025","title":"May 15, 2025","text":"<ul> <li>Hacked multiple ways to customize mkdocs material</li> </ul>"},{"location":"#may-14-2025","title":"May 14, 2025","text":"<ul> <li>Login &amp; SignUp buttons in custom-header for desktops with auth routes functionalities</li> </ul>"},{"location":"#may-13-2025","title":"May 13, 2025","text":"<ul> <li>Authentication , Authorization</li> </ul>"},{"location":"#may-12-2025","title":"May 12, 2025","text":"<ul> <li>Added Comment System</li> <li>74. Search a 2D Matrix</li> <li>240. Search a 2D Matrix II</li> </ul>"},{"location":"#may-11-2025","title":"May 11, 2025","text":"<ul> <li>Added FeedBack System</li> </ul>"},{"location":"#may-10-2025","title":"May 10, 2025","text":"<ul> <li>DSA Bible source code is private, deployment is public on ghpages with custom domain name.</li> </ul>"},{"location":"#may-9-2025","title":"May 9, 2025","text":"<ul> <li>Custom Theme setup</li> <li>non-sticky header</li> <li>TOC Optional</li> <li>path to Topic Navigation Page via topic tags</li> <li>inherit &amp; custom via code (optional) admomitions border-colors</li> </ul>"},{"location":"#may-8-2025","title":"May 8, 2025","text":"<ul> <li>Clean, Better solution to fetch all tags on index page using built-in tags (without macros).</li> <li>Clicking on a tag Array take user to respective tag on topics page.</li> <li>Problem Categories</li> </ul>"},{"location":"#may-7-2025","title":"May 7, 2025","text":"<ul> <li>One solution to fetch all tags on index page via macros using url path</li> </ul>"},{"location":"#may-6-2025","title":"May 6, 2025","text":"<ul> <li>Added new feature grouping pages based on TAGS Topics page</li> </ul>"},{"location":"#may-5-2025","title":"May 5, 2025","text":"<ul> <li>3. Composing flight crews</li> </ul>"},{"location":"#may-4-2025","title":"May 4, 2025","text":"<ul> <li>Added Mermaid, GraphViz extensions to support graphs,diagrams for</li> </ul>"},{"location":"#may-2-3-2025","title":"May 2 - 3, 2025","text":"<ul> <li>374. Guess Number Higher or Lower</li> <li>19. Remove Nth Node From End of List</li> </ul>"},{"location":"#may-1-2025","title":"May 1, 2025","text":"<ul> <li>Added Optimization problems with working online IDE</li> <li>1. Mixed Integer Programming</li> </ul>"},{"location":"#apr-14-30-2025","title":"Apr 14 - 30, 2025","text":"<ul> <li>Worked on building a compiler/interpreter/online ide.</li> </ul>"},{"location":"#apr-13-2025","title":"Apr 13, 2025","text":"<ul> <li>App with offline capabilities</li> </ul>"},{"location":"#apr-12-2025","title":"Apr 12, 2025","text":"<ul> <li>Web App is now PWA</li> <li>Significant improvement on focus, redeability</li> </ul>"},{"location":"#apr-11-2025","title":"Apr 11, 2025","text":"<ul> <li>Added CI/CD for auto deployment</li> </ul>"},{"location":"#apr-10-2025","title":"Apr 10, 2025","text":"<ul> <li>746. Min Cost Climbing Stairs</li> </ul>"},{"location":"#apr-9-2025","title":"Apr 9, 2025","text":"<ul> <li>Custom CSS for application</li> </ul>"},{"location":"#apr-8-2025","title":"Apr 8, 2025","text":"<ul> <li>135. Candy</li> </ul>"},{"location":"#apr-5-2025","title":"Apr 5, 2025","text":"<ul> <li>2226. Maximum Candies Allocated to K Children</li> </ul>"},{"location":"#apr-4-2025","title":"Apr 4, 2025","text":"<ul> <li>1. Two Sum</li> <li>2. Add Two Number</li> </ul>"},{"location":"definations/","title":"Definations","text":""},{"location":"definations/#subsequence","title":"Subsequence","text":"<ul> <li>A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</li> </ul>"},{"location":"definations/#substring","title":"Substring","text":"<ul> <li>A substring is a contiguous non-empty sequence of characters within a string.</li> </ul>"},{"location":"definations/#consider-a-string-of-n-characters-s_0s_1s_2s_n-1","title":"Consider a string of n characters: \"\\(s_0s_1s_2...s_{n-1}\\)\"","text":"<ul> <li>No. of <code>substring</code> = \\({C^n_2}\\) + \\({C^n_1}\\) = \\(n(n+1)/2\\)</li> <li>\\({C^n_2}\\) - because substring contains more than one character</li> <li>\\({C^n_1}\\) - because one character in itself is a substring</li> </ul> Akhil Singh Chauhan                          Author"},{"location":"pricing/","title":"Pricing","text":"Choose a Plan Monthly Yearly One-time Pro Plan <p>Gain access to all content!</p> $6 per month Subscribe <ul> <li>Unlock over 400 solutions across 28 problem categories</li> <li>Early access to new content</li> <li>Priority support</li> </ul> Pro Plan <p>Gain access to all content!</p> $51 per year Subscribe <ul> <li>Unlock over 400 solutions across 28 problem categories</li> <li>Early access to new content</li> <li>Priority support</li> </ul> Pro Plan <p>Gain access to all content!</p> $251 lifetime Buy Now <ul> <li>Unlock over 400 solutions across 28 problem categories</li> <li>Early access to new content</li> <li>Priority support</li> </ul>"},{"location":"privacy-policy/","title":"Privacy Policy","text":"<ol> <li> <p>Cookies</p> <p>This website, https://dsabible.com, uses cookies and similar technologies, which are small files or pieces of text that download to a device when a visitor accesses a website or app. These analytics and performance cookies are used on this website only when you acknowledge our cookie banner. This website uses analytics and performance cookies to view site traffic, activity, and other data and/or to provide you with a personalized experience.</p> <p>Change cookie settings</p> </li> <li> <p>Web Analysis Tools</p> <p>We may use web analysis tools that are built into this website to measure and collect anonymous session information.</p> <p>This website may collect personal data when you visit this website, including:</p> <ul> <li>Information about your browser, network, and device</li> <li>Web pages you visited prior to coming to this website</li> <li>Web pages you view while on this website</li> <li>Your IP address</li> </ul> <p>This website analyzes the data in a de-personalized form.</p> </li> <li> <p>Memberships/Subscriptions</p> <p>When you subscribe to and purchase a membership or subscription on this website, we collect personal information from you to enable your member area\u2019s access. We may collect information like your:</p> <ul> <li>Billing address</li> <li>Details relating to your subscription</li> <li>Email address</li> <li>Name</li> <li>Phone number</li> </ul> <p>As you go through checkout, this site may auto-complete your billing address by sharing what you type with the Google Places API and returning suggestions to you to improve your checkout experience. We may email you with messages about your order or account activity. For example, we may email you to tell you that:</p> <ul> <li>You\u2019ve created a customer account</li> <li>Your customer account password has been reset or updated</li> <li>You\u2019ve made a purchase</li> </ul> <p>It\u2019s not possible to unsubscribe from these messages.</p> </li> <li> <p>Payment</p> <p>If you make a purchase on our site, we use a third-party payment processor such as Stripe or Paypal. Payments are encrypted through the Payment Card Industry Data Security Standard (PCI-DSS). Your purchase transaction data is stored only as long as is necessary to complete your purchase transaction.</p> <p>All direct payment gateways adhere to the standards set by PCI-DSS as managed by the PCI Security Standards Council, which is a joint effort of brands like Visa, MasterCard, American Express, and Discover.</p> <p>Although no method of transmission over the Internet or electronic storage is 100% secure, we follow all PCI-DSS requirements and implement additional generally accepted industry standards.</p> </li> <li> <p>Third Party Services\u2019 Privacy Policies</p> <p>In general, the third-party providers used by us will only collect, use, and disclose your information to the extent necessary to allow them to perform the services they provide to us.</p> <p>However, certain third-party service providers, such as payment gateways and other payment transaction processors, have their own privacy policies in respect to the information we are required to provide to them for your purchase-related transactions.</p> <p>For these providers, we recommend that you read their privacy policies so you can understand the manner in which your personal information will be handled by these providers.</p> <p>Certain providers may be located in or have facilities that are located in a different jurisdiction than either you or us. If you elect to proceed with a transaction that involves the services of a third-party service provider, then your information may become subject to the laws of the jurisdiction(s) in which that service provider or its facilities are located.</p> <p>As an example, if you are located in Canada and your transaction is processed by a payment gateway located in the United States, then your personal information used in completing that transaction may be subject to disclosure under United States legislation, including the Patriot Act.</p> <p>Once you leave our website or are redirected to a third-party website or application, you are no longer governed by this Privacy Policy or our website\u2019s Terms of Service.</p> </li> <li> <p>Disclosure of Your Information</p> <p>We may disclose your personal information if we are required by law to do so or if you violate our Terms of Service located at https://dsabible.com/terms-of-service.</p> <p>To protect your personal information, we take reasonable precautions and follow industry best practices to make sure it is not inappropriately lost, misused, accessed, disclosed, altered, or destroyed.</p> </li> <li> <p>Changes to this Privacy Policy</p> <p>We reserve the right to modify this privacy policy at any time, so please review it frequently. Changes and clarifications will take effect immediately upon their posting on the website. If we make material changes to this policy, we will notify you here that it has been updated, so that you are aware of what information we collect, how we use it, and under what circumstances, if any, we use and/or disclose it.</p> <p>If our site is acquired or merged with another company, your information may be transferred to the new owner.</p> </li> <li> <p>Questions and Contact Information</p> <p>If you would like to access, correct, amend, or delete any personal information we have about you, register a complaint, or simply want more information, please contact us at info@dsabible.com.</p> </li> </ol>"},{"location":"style-guide/","title":"Naming Conventions","text":"<ul> <li>Class: UpperCamelCase</li> <li>Function: lowerCamelCase</li> <li>Variable: lower_snake_case</li> <li>Constant: UPPER_SNAKE_CASE</li> </ul>"},{"location":"style-guide/#examples","title":"Examples","text":"Python <pre><code># Class\nclass YourClass:\n  pass\n\n# Function\ndef yourFunction(param: int) -&gt; None:\n  pass\n\n# Variable\nyour_variable = 0\n\n# Constant\nK_MOD = 1_000_000_009\n</code></pre>"},{"location":"topics/","title":"TOPICS","text":"<p>Below is the classification of problems based on topics, useful while cementing any particular data structure, algorithm or topic.</p>"},{"location":"topics/#tag:array","title":"Array","text":"<ul> <li>            1. Two Sum          </li> <li>            135. Candy          </li> <li>            2226. Maximum Candies Allocated to K Children          </li> <li>            240. Search a 2D Matrix II          </li> <li>            407. Trapping Rain Water II          </li> <li>            42. Trapping Rain Water          </li> <li>            74. Search a 2D Matrix          </li> <li>            746. Min Cost Climbing Stairs          </li> </ul>"},{"location":"topics/#tag:backtracking","title":"Backtracking","text":"<ul> <li>            52. N-Queens II          </li> </ul>"},{"location":"topics/#tag:binary-search","title":"Binary Search","text":"<ul> <li>            2226. Maximum Candies Allocated to K Children          </li> <li>            240. Search a 2D Matrix II          </li> <li>            374. Guess Number Higher or Lower          </li> <li>            74. Search a 2D Matrix          </li> </ul>"},{"location":"topics/#tag:binary-search-tree","title":"Binary Search Tree","text":"<ul> <li>            703. Kth Largest Element in a Stream          </li> </ul>"},{"location":"topics/#tag:binary-tree","title":"Binary Tree","text":"<ul> <li>            703. Kth Largest Element in a Stream          </li> </ul>"},{"location":"topics/#tag:bit-manipulation","title":"Bit Manipulation","text":"<ul> <li>            29. Divide Two Integers          </li> </ul>"},{"location":"topics/#tag:breadth-first-search","title":"Breadth-First Search","text":"<ul> <li>            407. Trapping Rain Water II          </li> </ul>"},{"location":"topics/#tag:data-stream","title":"Data Stream","text":"<ul> <li>            703. Kth Largest Element in a Stream          </li> </ul>"},{"location":"topics/#tag:design","title":"Design","text":"<ul> <li>            703. Kth Largest Element in a Stream          </li> </ul>"},{"location":"topics/#tag:divide-and-conquer","title":"Divide and Conquer","text":"<ul> <li>            240. Search a 2D Matrix II          </li> </ul>"},{"location":"topics/#tag:dynamic-programming","title":"Dynamic Programming","text":"<ul> <li>            42. Trapping Rain Water          </li> <li>            746. Min Cost Climbing Stairs          </li> </ul>"},{"location":"topics/#tag:greedy","title":"Greedy","text":"<ul> <li>            135. Candy          </li> </ul>"},{"location":"topics/#tag:grind-169","title":"Grind 169","text":"<ul> <li>            1. Two Sum          </li> <li>            2. Add Two Numbers          </li> </ul>"},{"location":"topics/#tag:hash-table","title":"Hash Table","text":"<ul> <li>            1. Two Sum          </li> <li>            3. Longest Substring Without Repeating Characters          </li> </ul>"},{"location":"topics/#tag:heap-priority-queue","title":"Heap (Priority Queue)","text":"<ul> <li>            407. Trapping Rain Water II          </li> <li>            703. Kth Largest Element in a Stream          </li> </ul>"},{"location":"topics/#tag:interactive","title":"Interactive","text":"<ul> <li>            374. Guess Number Higher or Lower          </li> </ul>"},{"location":"topics/#tag:lp","title":"LP","text":"<ul> <li>            3. Composing flight crews          </li> <li>            4. N Queen          </li> </ul>"},{"location":"topics/#tag:linked-list","title":"Linked List","text":"<ul> <li>            19. Remove Nth Node From End of List          </li> <li>            2. Add Two Numbers          </li> </ul>"},{"location":"topics/#tag:mip","title":"MIP","text":"<ul> <li>            1. Mixed Integer Programming          </li> <li>            3. Composing flight crews          </li> <li>            4. N Queen          </li> </ul>"},{"location":"topics/#tag:math","title":"Math","text":"<ul> <li>            2. Add Two Numbers          </li> <li>            29. Divide Two Integers          </li> </ul>"},{"location":"topics/#tag:matrix","title":"Matrix","text":"<ul> <li>            240. Search a 2D Matrix II          </li> <li>            4. N Queen          </li> <li>            407. Trapping Rain Water II          </li> <li>            74. Search a 2D Matrix          </li> </ul>"},{"location":"topics/#tag:monotonic-stack","title":"Monotonic Stack","text":"<ul> <li>            42. Trapping Rain Water          </li> </ul>"},{"location":"topics/#tag:recursion","title":"Recursion","text":"<ul> <li>            2. Add Two Numbers          </li> </ul>"},{"location":"topics/#tag:sliding-window","title":"Sliding Window","text":"<ul> <li>            3. Longest Substring Without Repeating Characters          </li> </ul>"},{"location":"topics/#tag:stack","title":"Stack","text":"<ul> <li>            20. Valid Parentheses          </li> <li>            42. Trapping Rain Water          </li> </ul>"},{"location":"topics/#tag:string","title":"String","text":"<ul> <li>            20. Valid Parentheses          </li> <li>            3. Longest Substring Without Repeating Characters          </li> </ul>"},{"location":"topics/#tag:tree","title":"Tree","text":"<ul> <li>            703. Kth Largest Element in a Stream          </li> </ul>"},{"location":"topics/#tag:two-pointers","title":"Two Pointers","text":"<ul> <li>            19. Remove Nth Node From End of List          </li> <li>            42. Trapping Rain Water          </li> </ul>"},{"location":"_algorithms/sliding_window/","title":"Sliding window","text":""},{"location":"_algorithms/sliding_window/#sliding-window","title":"Sliding Window","text":"<pre><code>1.We can keep tracking a current window, and use two pointer to apply the sliding window algorithms.\n\n2.We can expand the window to the right greedily as long as the character is not existent in the current window.\n\n3.Otherwise, we need to move the left pointer and erase the corresponding characters at left pointer out of the window until the current character at the right pointer is no longer in the window.\n\n4.If we don\u2019t move the left pointer (shrink the window), the substring is not valid no matter how we move the right pointer.\n\n_The time complexity is $O(n)$ as the left and right pointers both move towards the right and the space complexity is $O(n)$ as we need a hash-set or dictionary to store the elements in the current window._\n</code></pre>"},{"location":"optimization/1/","title":"1. Mixed Integer Programming","text":"","tags":["MIP"]},{"location":"optimization/1/#1-mixed-integer-programming","title":"1. Mixed Integer Programming","text":"<p>Easy</p>","tags":["MIP"]},{"location":"optimization/1/#description","title":"Description","text":"<p>Formulate and solve the following simple MIP model:</p> <pre><code>Maximize\n    x + y + 2z\n\nsubject to constraints\n    x + 2y + 3z &lt;= 4\n    x +  y      &gt;= 1\n    x, y, z binary\n</code></pre>","tags":["MIP"]},{"location":"optimization/1/#test-your-code","title":"\ud83d\ude80 Test your code","text":"<p>Try to solve the problem below in the code editor before reading the solution.</p> View Answer <pre><code>Objective value: 3.0\nx: 1.0\ny: 0.0\nz: 1.0\n</code></pre>","tags":["MIP"]},{"location":"optimization/1/#solutions","title":"Solutions","text":"<p>","tags":["MIP"]},{"location":"optimization/1/#approach-1-using-mip-model","title":"Approach 1: Using MIP Model","text":"GurobiPulp <pre><code>import gurobipy as gp\nfrom gurobipy import GRB\n\ndef solveMipModel():\n\n    # Create a new model\n    m = gp.Model(\"mip1\")\n\n    # Create variables\n    x = m.addVar(vtype=GRB.BINARY, name=\"x\")\n    y = m.addVar(vtype=GRB.BINARY, name=\"y\")\n    z = m.addVar(vtype=GRB.BINARY, name=\"z\")\n\n    # Set objective\n    m.setObjective(x + y + 2 * z, GRB.MAXIMIZE)\n\n    # Add constraint: x + 2 y + 3 z &lt;= 4\n    m.addConstr(x + 2 * y + 3 * z &lt;= 4, \"c0\")\n\n    # Add constraint: x + y &gt;= 1\n    m.addConstr(x + y &gt;= 1, \"c1\")\n\n    # Optimize model\n    m.optimize()\n\n    print(f\"Objective value: {m.ObjVal:g}\")\n    for v in m.getVars():\n        print(f\"{v.VarName} {v.X:g}\")\n\n\nif __name__ == \"__main__\":\n    solve_mip_model()\n</code></pre> <pre><code>from pulp import *\n\ndef solveMipModel():\n\n    # Create the model\n    model = LpProblem(name=\"maximize_xyz\", sense=LpMaximize)\n\n    # Define the decision variables\n    x = LpVariable(name=\"x\", cat=LpBinary)\n    y = LpVariable(name=\"y\", cat=LpBinary)\n    z = LpVariable(name=\"z\", cat=LpBinary)\n\n    # Add the objective function\n    model += lpSum([x, y, 2*z]), \"objective_function\"\n\n    # Add the constraints\n    model += (x + 2*y + 3*z &lt;= 4), \"constraint_1\"\n    model += (x + y &gt;= 1), \"constraint_2\"\n\n    # Solve the model\n    model.solve()\n\n    # Print the results\n    print(f\"Status: {model.status}\")\n    print(f\"Objective value: {model.objective.value()}\")\n    for var in model.variables():\n        print(f\"{var.name}: {var.value()}\")\n\nif __name__ == \"__main__\":\n    solve_mip_model()\n</code></pre>","tags":["MIP"]},{"location":"optimization/1/#approach-2-using-matrix-api","title":"Approach 2: Using Matrix API\ud83d\udc4b Please log in to view the solution","text":"Gurobi <pre><code>import gurobipy as gp\nfrom gurobipy import GRB\nimport numpy as np\nimport scipy.sparse as sp\n\ntry:\n    # Create a new model\n    m = gp.Model(\"matrix1\")\n\n    # Create variables\n    x = m.addMVar(shape=3, vtype=GRB.BINARY, name=\"x\")\n\n    # Set objective\n    obj = np.array([1.0, 1.0, 2.0])\n    m.setObjective(obj @ x, GRB.MAXIMIZE)\n\n    # Build (sparse) constraint matrix\n    val = np.array([1.0, 2.0, 3.0, -1.0, -1.0])\n    row = np.array([0, 0, 0, 1, 1])\n    col = np.array([0, 1, 2, 0, 1])\n\n    A = sp.csr_matrix((val, (row, col)), shape=(2, 3))\n\n    # Build rhs vector\n    rhs = np.array([4.0, -1.0])\n\n    # Add constraints\n    m.addConstr(A @ x &lt;= rhs, name=\"c\")\n\n    # Optimize model\n    m.optimize()\n\n    print(x.X)\n    print(f\"Obj: {m.ObjVal:g}\")\n\nexcept gp.GurobiError as e:\n    print(f\"Error code {e.errno}: {e}\")\n\nexcept AttributeError:\n    print(\"Encountered an attribute error\")\n</code></pre> <p> <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["MIP"]},{"location":"optimization/2/","title":"2. Mermaid Examples","text":"<pre><code>flowchart LR\n\n    classDef smallNod2 fill:#f9f,stroke:#333,stroke-width:2px,width:500px,height:500px,font-size:260pt;\n\n    A((A)):::smallNode2\n    B((B)):::smallNode2\n    C((C)):::smallNode2\n\n    A---|This is the text|B\n    A--&gt;|text1|B\n    A-- text2 --&gt;B\n    A ----|text3| B\n    A -- text4 --&gt; B -- text1 --&gt; C\n    A-- This is the text6! ---B\n    B &lt;--text2--&gt; C\n    B e1@==&gt; C\n    e1@{ animate: true, animation: slow }</code></pre> <pre><code>%%{init: { 'flowchart': { 'curve': 'linear','htmlLabels': true } } }%%\ngraph LR\n    classDef smallNode fill:#f9f,stroke:#333,stroke-width:2px;\n\n    style 1 fill:#f9f,stroke:#333,stroke-width:2px, width:500px, height:500px\n    style 2 fill:#ccf,stroke:#333,stroke-width:2px, width:500px, height:500px\n    style 3 fill:#f9f,stroke:#333,stroke-width:2px, width:500px, height:500px\n    style 4 fill:#ccf,stroke:#333,stroke-width:2px, width:500px, height:500px\n    style 5 fill:#f9f,stroke:#333,stroke-width:2px, width:500px, height:500px\n    style 6 fill:#ccf,stroke:#333,stroke-width:2px, width:500px, height:500px\n    style 7 fill:#f9f,stroke:#333,stroke-width:2px, width:500px, height:500px\n    style 8 fill:#ccf,stroke:#333,stroke-width:2px, width:500px, height:500px\n\n    1((\"  1  \"))\n    2((\"  2  \"))\n    3((3))\n    4((4))\n    5((5))\n    6((6))\n    7((7))\n    8((8))\n\n    1----|30| 2\n    1---|24| 4\n    1----|25| 5\n\n    2----|27| 3\n    2---|28| 4\n    2----|27| 6\n\n    3----|30| 7\n    3-----|26| 6\n\n    4---|29| 5\n    4---|21| 6\n\n    5---|30| 6\n    5-----|30| 8\n\n    6---|28| 7\n    6---|36| 8\n\n    7-----|25| 8</code></pre>"},{"location":"optimization/2/#research-learning-resources","title":"Research, Learning Resources","text":"<ul> <li>Reference 1</li> <li>Reference 2</li> </ul>"},{"location":"optimization/3/","title":"3. Composing flight crews","text":"","tags":["MIP","LP"]},{"location":"optimization/3/#3-composing-flight-crews","title":"3. Composing flight crews","text":"<p>Ardous</p>","tags":["MIP","LP"]},{"location":"optimization/3/#description","title":"Description","text":"<p>During the Second World War the Royal Air Force (<code>RAF</code>) had many foreign pilots speaking different languages and more or less trained on the different types of aircraft. The <code>RAF</code> had to form pilot/co-pilot pairs (<code>crews</code>) for every plane with a compatible language and a sufficiently good knowledge of the aircraft type. In our example there are eight pilots. In the following table every pilot is characterized by a mark between <code>0 (worst)</code> and <code>20 (best)</code> for his language skills (in <code>English</code>, <code>French</code>, <code>Dutch</code>, and <code>Norwegian</code>), and for his experience with different two-seater aircraft (<code>reconnaissance</code>, <code>transport</code>, <code>bomber</code>, <code>fighterbomber</code>, and <code>supply planes</code>).</p> Pilot 1 2 3 4 5 6 7 8 Language English 20 14 0 13 0 0 8 8 French 12 0 0 10 15 20 8 9 Dutch 0 20 12 0 8 11 14 12 Norwegian 0 0 0 0 17 0 0 16 Plane type Reconnaissance 1 8 12 5 0 0 8 0 Transport 10 0 9 14 15 8 12 13 Bomber 0 17 0 11 13 10 0 0 Fighter Bomber 0 0 14 0 0 12 16 0 Supply plane 0 0 0 0 12 18 0 18 <p>Table 3.1 Ratings of pilots</p> <p>A valid flight crew consists of two pilots that both have each at least <code>10/20</code> for the same language and <code>10/20</code> on the same aircraft type.</p> <p>Question 1: Is it possible to have all pilots fly?</p> <p>Subsequently, we calculate for every valid flight crew the sum of their scores for every aircraft type for which both pilots are rated at least 10/20. This allows us to define for every crew the maximum score among these marks. For example, pilots 5 and 6 have marks 13 and 10 on bombers and 12 and 18 on supply planes. The score for this crew is therefore max(13 + 10, 12 + 18) = 30.</p> <p>Question 2: Which is the set of crews with maximum total score?</p>","tags":["MIP","LP"]},{"location":"optimization/3/#test-your-code","title":"\ud83d\ude80 Test your code","text":"<p>Try to solve the problem below in the code editor before reading the solution.</p>","tags":["MIP","LP"]},{"location":"optimization/3/#answer","title":"Answer","text":"<p> View Answer","tags":["MIP","LP"]},{"location":"optimization/3/#results","title":"Results","text":"<pre><code>Objective Value: 4\nArc (1,2): 30\nArc (3,7): 30\nArc (4,5): 29\nArc (6,8): 36\nCrew Score 125.0\n</code></pre> <p>In answer to the first question, the program finds that four crews are flying, that is, all eight pilots.</p> <p>For the second question, the optimization calculates a maximum total score of \\(125\\) for the four crews \\([1,2]\\), \\([3,7]\\), \\([4,5]\\), and \\([6,8]\\).</p> <p>G11221--230441--424551--525332--3272--428662--6273--626773--7304--5294--6215--630885--8306--7286--8367--825</p> <p>Figure 3.1:Compatibility graph for pilots</p>","tags":["MIP","LP"]},{"location":"optimization/3/#explanation","title":"Explanation","text":"<p>Let \\(PILOTS\\) be the set of pilots. This type of problem is easily modeled through an undirected compatibility graph \\(G = (PILOTS, ARCS)\\). Every node represents a pilot, two nodes \\(\\textit{p}\\) and \\(\\textit{q}\\) are connected by an undirected arc (or edge) \\(a = [\\textit{p}, \\textit{q}]\\) if and only if pilots \\(\\textit{p}\\) and \\(\\textit{q}\\) are compatible, that is, they have a language and a plane type in common for which both are rated at least <code>10/20</code>.</p> <p>The arcs are assigned weights corresponding to the maximum score \\(SCORE_a\\) of the flight crew. Figure 3.1 shows the resulting graph with the scores for question 2. A valid set of crews corresponds in \\(G\\) to a subset of arcs such that any two among them have no node in common. In Graph Theory, such a set is called a matching. For question 1 we are looking for the maximum cardinality matching, for question 2 for the matching with maximum total weight. The graph suggests we formulate the model as follows.</p>","tags":["MIP","LP"]},{"location":"optimization/3/#model-formulation","title":"Model Formulation","text":"\\[maximize \\sum_{a \\in ARCS} CREW_a \\cdot fly_a \\tag{3.1}\\] \\[\\forall r \\in PILOTS : \\sum_{\\substack{a=[p,q] \\in ARCS \\\\ p=r \\vee q=r}} fly_a \\leq 1 \\tag{3.2}\\] \\[\\forall a \\in ARCS : fly_a \\in \\{0, 1\\} \\tag{3.3}\\] <p>For every edge \\(a = [\\textit{p}, \\textit{q}]\\) in the graph, a binary variable \\(fly_a\\) indicates whether this edge is used or not (3.3). Through constraints (3.2) every node r is contained in at most one edge. The objective function (3.1) accumulates the weight of the chosen edges for question 2.</p> <p>For question 1, we maximize the number of flight crews to see whether all pilots are taken: the coefficients \\(SCORE_a\\) need to be removed from the objective function. Note that the matching of maximum cardinality is a special case of matching with maximum weight, with all weights equal to 1.</p>","tags":["MIP","LP"]},{"location":"optimization/3/#solutions","title":"Solutions","text":"Gurobi <pre><code>import gurobipy as gp\nfrom gurobipy import GRB\n\nPilot,Eng,Fre,Dut,Nor,Reco,Tran,Bomb,Figh,Supp = gp.multidict(\n    {\n        1: [20,12, 0,0 ,18,0 ,0 ,0 ,0 ],\n        2: [14,0 ,20,0 ,12,17,17,0 ,0 ],\n        3: [0 ,0 ,12,0 ,15,0 ,0 ,14,0 ],\n        4: [13,10,0 ,0 ,0 ,11,11,0 ,0 ],\n        5: [0 ,15,8 ,17,0 ,13,13,0 ,12],\n        6: [0 ,20,11,0 ,0 ,10,10,12,18],\n        7: [8 ,8 ,14,0 ,8 ,0 ,0 ,16,0 ],\n        8: [8 ,9 ,12,16,0 ,0 ,0 ,0 ,18],\n    }\n)\n\nArcs,scores = gp.multidict({\n(1,2): 30,\n(2,3): 27,\n(2,4): 28,\n(2,6): 27,\n(3,6): 26,\n(3,7): 30,\n(4,5): 29,\n(4,6): 21,\n(5,6): 30,\n(5,8): 30,\n(6,7): 28,\n(6,8): 36,\n})\n\nArcs = gp.tuplelist(Arcs)\n\nm =gp.Model('Composing flight crews')\n\nZ= m.addVar(vtype=GRB.INTEGER,obj=1, name=\"Z\")\n\nx={}\nfor i, j in Arcs:\n    x[i,j] = m.addVar(vtype=GRB.BINARY,obj=1, name=\"x_{}{}\".format(i,j))\n\nm.setObjective(Z,GRB.MAXIMIZE)\n\nm.update()\n\nfor p in Pilot:\n    m.addConstr(gp.quicksum(x[i,j] for i,j in Arcs.select(p,'*')) + gp.quicksum(x[j,i] for j,i in Arcs.select('*',p)) &lt;= 1)\n\n\nm.addConstr((gp.quicksum(x[i,j] for i,j in Arcs))==Z)\n\nm.optimize()\n\nprint('Objective Value: %g' % m.objVal)\n\n#Part (b) of problem\ncrew_score=0\nfor i, j in Arcs:\n    if x[i, j].x&gt;0.5:\n        crew_score+=scores[i,j]*x[i,j].x\n        print('Arc (%s,%s): %g' % (i, j, scores[i, j]))\n\nprint(\"Crew Score\",crew_score)\n</code></pre> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["MIP","LP"]},{"location":"optimization/4/","title":"4. N Queen","text":"<ul> <li>Add the explanation with equations</li> <li>Solution 1</li> </ul> <pre><code>from gurobipy import *\nimport os\n\nn=8\nx={}\n\nmodel = Model()\n\nfor i in range(n):\n    for j in range(n):\n        x[i+1,j+1] = model.addVar(vtype=GRB.BINARY, obj=1, name=\"x_{}{}\".format(i+1,j+1))\n\n\nmodel.update()\n\nmodel.addConstr(quicksum(x[i+1,j+1] for i in range(n) for j in range(n)) == n)\n\nfor i in range(n):\n    model.addConstr(quicksum(x[i+1,j+1] for j in range(n)) &lt;= 1)\n\nfor j in range(n):\n    model.addConstr(quicksum(x[i+1,j+1] for i in range(n)) &lt;= 1)\n\nfor k in range(1-n, n):\n    model.addConstr(quicksum(x[i+1,j+1] for i in range(n) for j in range(n) if i-j == k) &lt;= 1)\n\nfor l in range(0, 2*n-1):\n    model.addConstr(quicksum(x[i+1,j+1] for i in range(n) for j in range(n) if i+j == l) &lt;= 1)\n\n\n# Gurobi Settings\nmodel.params.LogToConsole = 0         # Quiet Gurobi\nmodel.params.PoolSearchMode = 2       # Force Gurobi to search for multiple optimal solutions\nmodel.params.PoolSolutions = 10**8    # Store max 10**8 Solutions in the solution pool\nmodel.params.PoolGap = 0              # All Solutions in the pool have 0 % Gap = optimal solutions\nmodel.optimize()\n\nprint(x)\nprint(f\"For n = {n} there are {model.SolCount} possible solutions\")\n\n# if model.status == GRB.status.OPTIMAL:\n#     model.write(\"Queens.lp\")\n#     os.system(\"imshow Queens.lp\")\n#     model.write(\"Queens.sol\")\n#     os.system(\"imshow Queens.sol\")\n# elif model.status == GRB.status.INFEASIBLE:\n#     model.computeIIS() # IIS tells you which constraints, when removed, makes the model feasible\n#     model.write('inf.ilp')\n</code></pre> <ul> <li>Solution 2 Fastest Solution can handle large values of n</li> </ul> <pre><code>import gurobipy as gp\nfrom gurobipy import GRB\n\nn = 8  # Size of the chessboard\n\n# Create a Gurobi model\nmodel = gp.Model(\"nqueens\")\n\n# Define binary decision variables\nx = model.addMVar((n, n), vtype=GRB.BINARY, name=\"x\")\n\n# At most one queen per row; this adds n linear constraints\nmodel.addConstr(x.sum(axis=1) &lt;= 1, name=\"row_constraints\")\n\n# At most one queen per column; this adds n linear constraints\nmodel.addConstr(x.sum(axis=0) &lt;= 1, name=\"col_constraints\")\n\n# At most one queen on each diagonal\nfor i in range(-n + 1, n):\n    # At most one queen on diagonal i\n    model.addConstr(x.diagonal(i).sum() &lt;= 1, name=f\"diag_pos_{i}\")\n\nfor i in range(-n + 1, n):\n    # At most one queen on anti-diagonal i\n    model.addConstr(x[:, ::-1].diagonal(i).sum() &lt;= 1, name=f\"diag_neg_{i}\")\n\n# Objective function (maximize number of queens placed)\nmodel.setObjective(x.sum(), GRB.MAXIMIZE)\n\n# Solve the model\nmodel.optimize()\n\n# Print the solution\nif model.status == GRB.OPTIMAL:\n    print(\"Solution found:\")\n    print(\"Board View\")\n    print(x.X)\n    print(f\"Queens position on board:\")\n    for i in range(n):\n        for j in range(n):\n            if x[i, j].X &gt; 0.5:\n                print(f\"({i+1}, {j+1})\")\nelse:\n    print(\"No solution found.\")\n</code></pre>","tags":["MIP","LP","Matrix"]},{"location":"optimization/5/","title":"5. GraphViz Examples","text":""},{"location":"optimization/5/#example-1","title":"Example 1","text":"<ol> <li><code>splines=false</code> doesn't work well with labels - it often causes unexpected behavior</li> <li><code>splines=line</code> is better for straight edges with labels</li> <li>The layout engine (dot, neato, fdp, etc.) significantly affects how edges are drawn</li> <li>Increasing <code>nodesep</code> and <code>ranksep</code> gives more space for straight edges</li> <li>Using <code>labelfloat=true</code> can help position labels better</li> </ol> <p>G11221--2441--4551--5332--32--4662--63--6773--74--54--65--6885--86--76--87--825</p> <ul> <li><code>nodesep</code> for horizontal spacing</li> <li><code>ranksep</code> for more vertical spacing</li> <li><code>len</code> values for longer individual edges</li> </ul>"},{"location":"optimization/5/#example-2","title":"Example 2","text":"<p>G11221--230441--424551--5252--428332--327662--6274--5294--6215--630885--8303--626773--7306--7286--8367--825</p>"},{"location":"optimization/5/#research-learning-resources","title":"Research, Learning Resources","text":"<ul> <li>Reference 1</li> <li>Reference 2</li> <li>Reference 3</li> <li>Reference 4</li> <li>Reference 5</li> <li>Reference 6</li> <li>Reference 7</li> <li>Plugin Reference 1</li> <li>Plugin Reference 2</li> <li>Plugin Reference 3</li> <li>Plugin Reference 4</li> <li>Graph Reference</li> </ul>"},{"location":"optimization/6/","title":"More Optimization Problems Coming Soon","text":"<p> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author"},{"location":"problems/1/","title":"1. Two Sum","text":"","tags":["Grind 169","Array","Hash Table"]},{"location":"problems/1/#1-two-sum","title":"1. Two Sum","text":"<p>Easy</p>","tags":["Grind 169","Array","Hash Table"]},{"location":"problems/1/#description","title":"Description","text":"<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p> <p>Example 1:</p> <pre><code>Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n</code></pre> <p>Example 2:</p> <pre><code>Input: nums = [3,2,4], target = 6\nOutput: [1,2]\n</code></pre> <p>Example 3:</p> <pre><code>Input: nums = [3,3], target = 6\nOutput: [0,1]\n</code></pre> <p>Constraints:</p> <ul> <li><code>2 &lt;= nums.length &lt;= 104</code></li> <li><code>-109 &lt;= nums[i] &lt;= 109</code></li> <li><code>-109 &lt;= target &lt;= 109</code></li> <li><code>Only one valid answer exists.</code></li> </ul> <p>Follow-up: Can you come up with an algorithm that is less than \\(O(n^2)\\) time complexity?</p>","tags":["Grind 169","Array","Hash Table"]},{"location":"problems/1/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p>","tags":["Grind 169","Array","Hash Table"]},{"location":"problems/1/#approach-1-hash-table","title":"Approach 1: Hash Table","text":"<p> Time complexity: \\(O(n)\\)</p> <p> Space complexity: \\(O(n)\\)</p>","tags":["Grind 169","Array","Hash Table"]},{"location":"problems/1/#way-1","title":"Way 1","text":"<p>Algorithmic</p> <p>We can use the hash table \\(seen\\) to store the array value and the corresponding index.</p> <p>Traverse the array <code>nums</code>, when you find <code>target - nums[i]</code> in the hash table, it means that the target value is found, and the index of <code>target - nums[i]</code> and \\(i\\) are returned.</p> <p>The time complexity is \\(O(n)\\) and the space complexity is \\(O(n)\\). Where \\(n\\) is the length of the input array <code>nums</code>.</p> PythonJavaCC++GoTypeScriptRustJavaScriptC#PHPScalaSwiftRubyKotlinNimCangjie <pre><code>class Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        seen = {} #map elements with their indexs {ele:idx}\n        for idx,ele in enumerate(nums):\n            num = target - ele\n            if num in seen:\n                return [seen[num],idx]\n            seen[ele] = idx\n</code></pre> <pre><code>class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n</code></pre> <pre><code>/**\n* Note: The returned array must be malloced, assume caller calls free().\n*/\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; indices;\n        for (int i = 0; i &lt; nums.size(); i++) {\n            int complement = target - nums[i];\n            if (indices.count(complement)) {\n                return {indices[complement], i};\n            }\n            indices[nums[i]] = i;\n        }\n        return {};\n    }\n};\n</code></pre> <pre><code>func twoSum(nums []int, target int) []int {\n}\n</code></pre> <pre><code>function twoSum(nums: number[], target: number): number[] {\n    const seen = new Map();\n    for (let i = 0; i &lt; nums.length; i++) {\n        const diff = target - nums[i];\n        if (seen.has(diff)) {\n            return [seen.get(diff), i];\n        }\n        seen.set(nums[i], i);\n    }\n    return [];\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {\n\n    }\n}\n</code></pre> <pre><code>/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n*/\n\nvar twoSum = function (nums, target) {\n\n}\n</code></pre> <pre><code>public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    /**\n    * @param Integer[] $nums\n    * @param Integer $target\n    * @return Integer[]\n    */\n    function twoSum($nums, $target) {\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def twoSum(nums: Array[Int], target: Int): Array[Int] = {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] {\n\n    }\n}\n</code></pre> <pre><code># @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef two_sum(nums, target)\n\nend\n</code></pre> <pre><code>class Solution {\n    fun twoSum(nums: IntArray, target: Int): IntArray {\n\n    }\n}\n</code></pre> <pre><code>proc twoSum(nums: seq[int], target: int): seq[int] =\n</code></pre> <pre><code>class Solution {\n    func twoSum(nums: Array&lt;Int64&gt;, target: Int64): Array&lt;Int64&gt; {\n\n    }\n}\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Grind 169","Array","Hash Table"]},{"location":"problems/135/","title":"135. Candy","text":"","tags":["Array","Greedy"]},{"location":"problems/135/#135-candy","title":"135. Candy","text":"<p>Hard</p>","tags":["Array","Greedy"]},{"location":"problems/135/#description","title":"Description","text":"<p>There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.</p> <p>You are giving candies to these children subjected to the following requirements:</p> <pre><code>- Each child must have at least one candy.\n- Children with a higher rating get more candies than their neighbors.\n</code></pre> <p>Return the minimum number of candies you need to have to distribute the candies to the children.</p> <p>Example 1:</p> <pre><code>Input: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n</code></pre> <p>Example 2:</p> <pre><code>Input: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n</code></pre> <p>Constraints:</p> <ul> <li><code>n == ratings.length</code></li> <li><code>1 &lt;= n &lt;= 2 * 104</code></li> <li><code>0 &lt;= ratings[i] &lt;= 2 * 104</code></li> </ul>","tags":["Array","Greedy"]},{"location":"problems/135/#solutions","title":"Solutions","text":"<p>","tags":["Array","Greedy"]},{"location":"problems/135/#approach-greedy","title":"Approach: Greedy","text":"<p> Time complexity: \\(O(n)\\)</p> <p> Space complexity: \\(O(n)\\)</p>","tags":["Array","Greedy"]},{"location":"problems/135/#way-1","title":"Way 1:","text":"<p>Algorithmic Way</p> <p>We initialize a <code>candies</code> array with 1 candy for each child.</p> <p>First, we go left to right: if a child has a higher rating than the one before, they get one more candy.</p> <p>Then, we go right to left: if a child has a higher rating than the one after, we ensure they have more candies by taking the max of current and one more than the next.</p> <p>Finally, we sum all <code>candies</code> and return the total.</p> <p>Time complexity <code>O(n)</code> , Space complexity <code>O(n)</code>.Where n is the number of children.</p> Python <pre><code>class Solution:\n    def candy(self, ratings: List[int]) -&gt; int:\n        n = len(ratings)\n        candies = [1] * n\n        # Left to right pass\n        for i in range(1, n):\n            if ratings[i] &gt; ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        # Right to left pass\n        for i in range(n - 2, -1, -1):\n            if ratings[i] &gt; ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        return sum(candies)\n</code></pre>","tags":["Array","Greedy"]},{"location":"problems/135/#way-2","title":"Way 2:","text":"<p>Notes</p> <p>We initialize two arrays <code>L</code> and <code>R</code>, where <code>L[i]</code> represents the minimum number of candies the current child should get when the current child's score is higher than the left child's score, and <code>R[i]</code> represents the minimum number of candies the current child should get when the current child's score is higher than the right child's score. Initially, <code>L[i]</code> = 1, <code>R[i]</code> = 1.</p> <p>We traverse the array from left to right once, and if the current child's score is higher than the left child's score, then <code>L[i] = L[i - 1] + 1</code>;</p> <p>Similarly, we traverse the array from right to left once, and if the current child's score is higher than theright child's score, then <code>R[i] = R[i+1] + 1</code>. Finally, we traverse the array of scores once, and the minimum number of candies each child should get is the maximum of <code>L[i]</code> and <code>R[i]</code>, and we add them up to get the answer.</p> <p>Time complexity <code>O(n)</code>, space complexity <code>O(n)</code>. Where <code>n</code> is the length of the array of scores.</p> Python <pre><code>class Solution:\n    def candy(self, ratings: List[int]) -&gt; int:\n        n = len(ratings)\n        L = [1]*n\n        R = [1]*n\n        ans = 0\n        for i in range(1,n):\n            if ratings[i]&gt;ratings[i-1]:\n                L[i] = L[i-1] +1\n\n        for i in range(n-2,-1,-1):\n            if ratings[i]&gt;ratings[i+1]:\n                R[i] = R[i+1] + 1\n\n        for l,r in zip(L,R):\n            ans+=max(l,r)\n\n        return ans\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Array","Greedy"]},{"location":"problems/19/","title":"19. Remove Nth Node From End of List","text":"","tags":["Linked List","Two Pointers"]},{"location":"problems/19/#19-remove-nth-node-from-end-of-list","title":"19. Remove Nth Node From End of List","text":"<p>Medium</p>","tags":["Linked List","Two Pointers"]},{"location":"problems/19/#description","title":"Description","text":"<p>Given the <code>head</code> of a linked list, remove the n<sup>th</sup> node from the end of the list and return its head.</p> <p>Example 1:</p> <p></p> <pre><code>Input: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n</code></pre> <p>Example 2:</p> <pre><code>Input: head = [1], n = 1\nOutput: []\n</code></pre> <p>Example 3:</p> <pre><code>Input: head = [1,2], n = 1\nOutput: [1]\n</code></pre> <p>Constraints:</p> <ul> <li><code>The number of nodes in the list is sz.</code></li> <li><code>1 &lt;= sz &lt;= 30</code></li> <li><code>0 &lt;= Node.val &lt;= 100</code></li> <li><code>1 &lt;= n &lt;= sz</code></li> </ul> <p>Follow up: Could you do this in one pass?</p>","tags":["Linked List","Two Pointers"]},{"location":"problems/19/#solutions","title":"Solutions","text":"<p>","tags":["Linked List","Two Pointers"]},{"location":"problems/19/#approach-fast-and-slow-pointers","title":"Approach: Fast and Slow pointers","text":"<p> Time complexity: \\(O(n)\\)</p> <p> Space complexity: \\(O(1)\\)</p>","tags":["Linked List","Two Pointers"]},{"location":"problems/19/#way-1","title":"Way 1:","text":"<p>Algorithm 1</p> <p>We define two pointers <code>fast</code> and <code>slow</code>,both initially pointing to the dummy head node of the linked list.</p> <p>Next, the<code>fast</code>pointer moves forward <code>n</code> steps first, then<code>fast</code>and <code>slow</code> pointers move forward together until the<code>fast</code>pointer reaches the end of the linked list. At this point, the node pointed to by <code>slow</code> next is the predecessor of the n-th node from the end, and we can delete it.</p> <p>The time complexity is \ud835\udc42(\ud835\udc5b) where \ud835\udc5b is the length of the linked list. The space complexity is \ud835\udc42(1).</p> Python <pre><code>class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n        #Create a dummy node to handle edge cases\n        dummy = ListNode(0,head)\n\n        #Intialize pointer fast and slow\n        slow = fast = head\n\n        #Move fast pointer n nodes ahead\n        for _ in range(n):\n            fast = fast.next\n\n        #Move both pointers until fast reaches end\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n\n        #Remove the nth node from the end\n        slow.next = slow.next.next\n\n        return dummy.next\n</code></pre> equivalency <pre><code>dummy = ListNode(0)\ndummy.next = head\n        ||\n        ||\n        ||\ndummy = ListNode(0,head)\n</code></pre>","tags":["Linked List","Two Pointers"]},{"location":"problems/19/#approach-simulation","title":"Approach: Simulation","text":"<p> Time complexity: \\(O(n)\\)</p> <p> Space complexity: \\(O(1)\\)</p>","tags":["Linked List","Two Pointers"]},{"location":"problems/19/#way-2","title":"Way 2:","text":"<p>Algorithm 2</p> Python <pre><code>class Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:\n        #Calculate length\n        tail , length = head, 0\n        while tail:\n            length+=1\n            tail = tail.next\n\n        #Use a dummy node to handle edge cases, such as removing the head of the list.\n        dummy = ListNode(0, head)\n        curr = dummy\n\n        #Find the node just before the one we want to remove\n        for _ in range(length-n):\n            curr = curr.next\n\n        #Remove the connection(nth node from the end)\n        if curr.next:\n            curr.next = curr.next.next\n\n        return dummy.next\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Linked List","Two Pointers"]},{"location":"problems/2/","title":"2. Add Two Numbers","text":"","tags":["Grind 169","Linked List","Math","Recursion"]},{"location":"problems/2/#2-add-two-numbers","title":"2. Add Two Numbers","text":"<p>Medium</p>","tags":["Grind 169","Linked List","Math","Recursion"]},{"location":"problems/2/#description","title":"Description","text":"<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p> <p>Example 1:</p> <p></p> <pre><code>Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n</code></pre> <p>Example 2:</p> <pre><code>Input: l1 = [0], l2 = [0]\nOutput: [0]\n</code></pre> <p>Example 3:</p> <pre><code>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n</code></pre> <p>Constraints:</p> <ul> <li><code>The number of nodes in each linked list is in the range [1, 100].</code></li> <li><code>0 &lt;= Node.val &lt;= 9</code></li> <li><code>It is guaranteed that the list represents a number that does not have leading zeros.</code></li> </ul>","tags":["Grind 169","Linked List","Math","Recursion"]},{"location":"problems/2/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p>","tags":["Grind 169","Linked List","Math","Recursion"]},{"location":"problems/2/#approach-1-simulation","title":"Approach 1: Simulation","text":"<p> Time complexity: \\(O(max((M,N)))\\)</p> <p> Space complexity: \\(O(1)\\)</p>","tags":["Grind 169","Linked List","Math","Recursion"]},{"location":"problems/2/#way-1","title":"Way 1","text":"<p>Algorithmic</p> <p>We traverse two linked lists and at the same time, and use the variable \\(carry\\) to indicate whether there is a carry.</p> <p>Each time we traverse, we take out the current bit of the corresponding linked list, calculate the sum with the carry \\(carry\\), and then update the value of the carry. Then we add the current bit to the answer linked list.</p> <p>If both linked lists are traversed, and the carry is 0, the traversal ends.</p> <p>Finally, we return the <code>head</code> node of the answer linked list.</p> <p>The time complexity is \\(O(max((M,N)))\\), where \\(M\\) and \\(N\\) are the lengths of the two linked lists. We need to traverse the entire position of the two linked lists, and each position only needs \\(O(1)\\) time. Ignoring the space consumption of the answer, the space complexity is \\(O(1)\\).</p> PythonJavaC++GoTypeScriptRustJavaScriptC#PHPSwiftRuby <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        while l1 or l2 or carry:\n            if l1:\n                carry+=l1.val\n                l1 = l1.next\n            if l2:\n                carry+=l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry%10)\n            carry = carry//10\n            curr = curr.next\n        return dummy.next\n</code></pre> <pre><code>class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n\n    }\n};\n</code></pre> <pre><code>func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {\n}\n</code></pre> <pre><code>function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n}\n</code></pre> <pre><code>impl Solution {\n    pub fn add_two_numbers(\n    mut l1: Option&lt;Box&lt;ListNode&gt;&gt;,\n    mut l2: Option&lt;Box&lt;ListNode&gt;&gt;,\n) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {\n\n    }\n}\n</code></pre> <pre><code>/**\n* @param {ListNode} l1\n* @param {ListNode} l2\n* @return {ListNode}\n*/\nvar addTwoNumbers = function (l1, l2) {\n\n}\n</code></pre> <pre><code>public class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    /**\n    * @param ListNode $l1\n    * @param ListNode $l2\n    * @return ListNode\n    */\n    function addTwoNumbers($l1, $l2) {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? {\n\n    }\n}\n</code></pre> <pre><code># @param {ListNode} l1\n# @param {ListNode} l2\n# @return {ListNode}\ndef add_two_numbers(l1, l2)\n\nend\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Grind 169","Linked List","Math","Recursion"]},{"location":"problems/20/","title":"20. Valid Parentheses","text":"","tags":["String","Stack"]},{"location":"problems/20/#20-valid-parentheses","title":"20. Valid Parentheses","text":"<p>Easy</p>","tags":["String","Stack"]},{"location":"problems/20/#description","title":"Description","text":"<p>Given a string s containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p> <p>An input string is valid if:</p> <ol> <li>Open brackets must be closed by the same type of brackets.</li> <li>Open brackets must be closed in the correct order.</li> <li>Every close bracket has a corresponding open bracket of the same type.</li> </ol> <p>Example 1:</p> <pre><code>Input: s = \"()\"\n\nOutput: true\n</code></pre> <p>Example 2:</p> <pre><code>Input: s = \"()[]{}\"\n\nOutput: true\n</code></pre> <p>Example 3:</p> <pre><code>Input: s = \"(]\"\n\nOutput: false\n</code></pre> <p>Example 4:</p> <pre><code>Input: s = \"([])\"\n\nOutput: true\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= s.length &lt;= 104</code></li> <li><code>s consists of parentheses only '()[]{}'</code></li> </ul>","tags":["String","Stack"]},{"location":"problems/20/#solutions","title":"Solutions","text":"<p>","tags":["String","Stack"]},{"location":"problems/20/#approach-stack","title":"Approach: Stack","text":"<p> Time complexity: \\(O(n)\\)</p> <p> Space complexity: \\(O(n)\\)</p>","tags":["String","Stack"]},{"location":"problems/20/#way-1","title":"Way 1:","text":"<p>Algorithmic Way</p> <p>Traverse the bracket string <code>s</code>.</p> <ul> <li> <p>When encountering a left bracket, push the current left bracket into the stack;</p> </li> <li> <p>When encountering a right bracket, pop the top element of the stack (if the stack is empty, directly return false), and judge whether it matches. If it does not match, directly return false.</p> </li> </ul> <p>At the end of the traversal,</p> <ul> <li>if the stack is empty, it means the bracket string is valid, return true; otherwise, return false.</li> </ul> <p>The time complexity is \\(O(n)\\), and the space complexity is \\(O(n)\\). Here, n is the length of the bracket string .</p> Python <pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n        stack = []\n        valid = [\"()\",\"{}\",\"[]\"]         # valid = {'()', '[]', '{}'}\n\n        for ch in s:\n            if ch in '({[':\n                stack.append(ch)\n            elif not stack or not (stack.pop() + ch in valid):\n                return False\n        return not stack\n</code></pre>","tags":["String","Stack"]},{"location":"problems/20/#way-2","title":"Way 2:","text":"<p>Using a dictionary or hashMap</p> PythonTypeScriptJavaScript <pre><code>class Solution:\n    def isValid(self, s: str) -&gt; bool:\n        mp = {\n            '(':')',\n            '[':']',\n            '{':'}'\n        }\n\n        stk = []\n\n        for ch in s:\n            if ch in mp:\n                stk.append(mp[ch])\n            elif not stk or stk.pop()!=ch:\n                return False\n\n        return len(stk)==0\n</code></pre> <pre><code>function isValid(s: string): boolean {\n    const mp = new Map([\n        ['(', ')'],\n        ['[', ']'],\n        ['{', '}'],\n    ]);\n\n    const stack = [];\n\n    for (const c of s) {\n        if (mp.has(c)) {\n            stack.push(mp.get(c));\n        } else if (stack.pop() !== c) {\n            return false;\n        }\n    }\n    return stack.length === 0;\n}\n</code></pre> <pre><code>/**\n * @param {string} s\n * @return {boolean}\n */\nvar isValid = function(s) {\n    let stk = []\n    const mp = {'(':')','[':']','{':'}'}\n\n    for (const ch of s){\n        if(ch in mp) {\n            stk.push(mp[ch])\n        }\n        else if (stk.length === 0 || stk.pop()!==ch) {\n            return false\n        }\n    }\n    return stk.length == 0\n};\n</code></pre> What is the difference between HashMap and HashTable in JavaScript? <p>Both Hash Tables and Hashmap provide a key/value functionality but there is a slight difference. Hashmap offers the ability of the keys to be of any data type, unlike Hash Tables where the keys can only be integers and strings. Also, Hashmaps can not be converted to JSON.</p> <p>Read more...</p> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["String","Stack"]},{"location":"problems/2140/","title":"Coming Soon","text":"<p> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author"},{"location":"problems/2226/","title":"2226. Maximum Candies Allocated to K Children","text":"","tags":["Array","Binary Search"]},{"location":"problems/2226/#2226-maximum-candies-allocated-to-k-children","title":"2226. Maximum Candies Allocated to K Children","text":"<p>Medium</p>","tags":["Array","Binary Search"]},{"location":"problems/2226/#description","title":"Description","text":"<p>You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.</p> <p>You are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can be allocated candies from only one pile of candies and some piles of candies may go unused.</p> <p>Return the maximum number of candies each child can get.</p> <p>Example 1:</p> <pre><code>Input: candies = [5,8,6], k = 3\nOutput: 5\nExplanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n</code></pre> <p>Example 2:</p> <pre><code>Input: candies = [2,5], k = 11\nOutput: 0\nExplanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= candies.length &lt;= 105</code></li> <li><code>1 &lt;= candies[i] &lt;= 107</code></li> <li><code>1 &lt;= k &lt;= 1012</code></li> </ul>","tags":["Array","Binary Search"]},{"location":"problems/2226/#solutions","title":"Solutions","text":"<p>","tags":["Array","Binary Search"]},{"location":"problems/2226/#approach-1-applied-binary-search","title":"Approach 1: Applied Binary Search","text":"<p> Time complexity: \\(O(n \\times \\log M)\\)</p> <p> Space complexity: \\(O(1)\\)</p> <p>Notes</p> <p>We notice that if each child can receive <code>v</code> candies, then for any <code>v' &lt; v</code>, each child can also receive <code>v'</code> candies. Therefore, we can use binary search to find the maximum <code>v</code> such that each child can receive <code>v</code> candies. We define the left boundary of the binary search as \\(l = 0\\) and the right boundary as \\(r = max(candies)\\), where <code>max(candies)</code> represents the maximum value in the array candies. During the binary search, we take the middle value \\(mid = (l+r+1)//2 = \u230a(l+r+1)/2\u230b\\) each time, and then calculate the total number of candies each child can receive.</p> <p>If the total is greater than or equal to <code>k</code>, it means each child can receive v candies, so we update the left boundary \\(l = mid\\). Otherwise, we update the right boundary \\(r = mid - 1\\). Finally, when \\(l = r\\), we have found the maximum <code>v</code>. The time complexity is \\(O(n \\times log M)\\), where <code>n</code> is the length of the array candies, and <code>M</code> is the maximum value in the array candies. The space complexity is \\(O(1)\\).</p>","tags":["Array","Binary Search"]},{"location":"problems/2226/#way-1","title":"Way 1:","text":"Python <pre><code>class Solution:\n    def maximumCandies(self, candies: List[int], k: int) -&gt; int:\n        def f(mid):                     #f - numChildren is a function of candies\n            return sum((c//mid) for c in candies)\n\n        l, r = 1, max(candies)\n        ans = 0\n        while l &lt;=r:\n            mid = (l + r ) // 2\n            if f(mid)&gt;=k:\n                ans = mid\n                l = mid +1\n            else:\n                r = mid -1\n        return ans\n</code></pre>","tags":["Array","Binary Search"]},{"location":"problems/2226/#way-2","title":"Way 2:","text":"<p>Tip</p> <ul> <li>Binary Search different than the regular one</li> <li>Problem function is monotonically decresing and we are looking for maximum</li> </ul> Python <pre><code>class Solution:\n    def maximumCandies(self, candies: List[int], k: int) -&gt; int:\n        def f(mid):                    #f - numChildren is a function of candies\n            return sum((c//mid) for c in candies)\n\n        l, r = 0, max(candies)\n        while l&lt;r:\n            mid = (l + r +1) &gt;&gt; 1      #see deviation here from regular binary search\n            if f(mid) &gt;= k:\n                l = mid                #see deviation here from regular binary search\n            else:\n                r = mid - 1            #see deviation here from regular binary search\n        return l\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Array","Binary Search"]},{"location":"problems/240/","title":"240. Search a 2D Matrix II","text":"","tags":["Array","Binary Search","Divide and Conquer","Matrix"]},{"location":"problems/240/#240-search-a-2d-matrix-ii","title":"240. Search a 2D Matrix II","text":"<p>Medium</p>","tags":["Array","Binary Search","Divide and Conquer","Matrix"]},{"location":"problems/240/#description","title":"Description","text":"<p>Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:</p> <ul> <li>Integers in each row are sorted in ascending from left to right.</li> <li>Integers in each column are sorted in ascending from top to bottom.</li> </ul> <p>Example 1:</p> <pre><code>Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\nOutput: true\n</code></pre> <p></p> <p>Example 2:</p> <pre><code>Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\nOutput: false\n</code></pre> <p></p> <p>Constraints:</p> <ul> <li><code>m == matrix.length</code></li> <li><code>n == matrix[i].length</code></li> <li><code>1 &lt;= n, m &lt;= 300</code></li> <li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li> <li><code>All the integers in each row are sorted in ascending order.</code></li> <li><code>All the integers in each column are sorted in ascending order.</code></li> <li><code>-109 &lt;= target &lt;= 109</code></li> </ul>","tags":["Array","Binary Search","Divide and Conquer","Matrix"]},{"location":"problems/240/#solutions","title":"Solutions","text":"<p>","tags":["Array","Binary Search","Divide and Conquer","Matrix"]},{"location":"problems/240/#approach-search-from-the-bottom-left-or-top-right","title":"Approach : Search from the Bottom Left or Top Right","text":"<p> Time complexity: \\(O(m + n)\\)</p> <p> Space complexity: \\(O(1)\\)</p> <p>Algorithmic</p> <p>Here, we start searching from the bottom-left and move towards the top-right direction. We compare the current element \\(\\textit{matrix}[row][col]\\) with \\(\\textit{target}\\):</p> <ul> <li>If \\(\\textit{matrix}[row][col] = \\textit{target}\\), it means the target value is found, and we return \\(\\text{true}\\).</li> <li>If \\(\\textit{matrix}[row][col] &gt; \\textit{target}\\), it means all elements in this column from the current position upwards are greater than \\(\\textit{target}\\), so we move the \\(row\\) pointer upwards, i.e., \\(row \\leftarrow row - 1\\).</li> <li>If \\(\\textit{matrix}[row][col] &lt; \\textit{target}\\), it means all elements in this row from the current position to the right are less than \\(\\textit{target}\\), so we move the \\(col\\) pointer to the right, i.e., \\(col \\leftarrow col + 1\\).</li> </ul> <p>If the search ends and the \\(\\textit{target}\\) is not found, return \\(\\text{false}\\).</p> <p>The time complexity is \\(O(m + n)\\), where \\(m\\) and \\(n\\) are the number of rows and columns of the matrix, respectively. The space complexity is \\(O(1)\\).</p> Python <pre><code>class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        if not matrix or not matrix[0]:\n            return False\n        m , n = len(matrix) , len(matrix[0])\n        row = m-1\n        col = 0\n        while row &gt;= 0 and col &lt; n:\n            if matrix[row][col]==target:\n                return True\n\n            if matrix[row][col] &gt; target:\n                row -= 1 # all numbers in that row are even larger\n            else:                       #matrix[row][col]&lt;target\n                col += 1 # all numbers in this row from current position col are smaller\n\n        return False\n</code></pre>","tags":["Array","Binary Search","Divide and Conquer","Matrix"]},{"location":"problems/240/#approach-1d-binary-search","title":"Approach : 1D-Binary Search","text":"<p> Time complexity: \\(O(m \\log(n))\\)</p> <p> Space complexity: \\(O(1)\\)</p>","tags":["Array","Binary Search","Divide and Conquer","Matrix"]},{"location":"problems/240/#way-1","title":"Way 1","text":"<p>Algorithmic</p> <ul> <li>Applicable to searching target in a 2D row-wise sorted matrix</li> </ul> <p>Since all elements in each row are sorted in ascending order, for each row, we can use binary search to find the first element greater than or equal to \\(\\textit{target}\\), and then check if that element is equal to \\(\\textit{target}\\). If it is equal to \\(\\textit{target}\\), it means the target value is found, and we return \\(\\text{true}\\). If it is not equal to \\(\\textit{target}\\), it means all elements in this row are less than \\(\\textit{target}\\), and we should continue searching the next row.</p> <p>If all rows have been searched and the target value is not found, it means the target value does not exist, and we return \\(\\text{false}\\).</p> <p>The time complexity is \\(O(m \\times \\log n)\\), where \\(m\\) and \\(n\\) are the number of rows and columns of the matrix, respectively. The space complexity is \\(O(1)\\).</p> Python <pre><code>class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        def binarySearch(arr, target):\n            l, r = 0, len(arr) - 1\n            while l &lt;= r:\n                mid = (r+l)//2\n                if arr[mid]==target:\n                    return True\n\n                if arr[mid]&gt;target:\n                    r=mid-1\n                else:\n                    l=mid+1\n\n            return False\n\n        for arr in matrix:\n            if binarySearch(arr, target):\n                return True\n        return False\n</code></pre> equivalency <pre><code>mid = (r+l)//2\n    ||\n    ||\n    ||\nmid = floor((r+l)/2)\n    ||\n    ||\n    ||\nmid = (l+r)&gt;&gt;1\n    ||\n    ||\n    ||\nmid = (r-(r-l)//2)\n</code></pre>","tags":["Array","Binary Search","Divide and Conquer","Matrix"]},{"location":"problems/240/#way2","title":"Way2","text":"<p>Pythonic</p> Python <pre><code>class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        for row in matrix:\n            j = bisect_left(row, target)\n            if j &lt; len(matrix[0]) and row[j] == target:\n                return True\n        return False\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Array","Binary Search","Divide and Conquer","Matrix"]},{"location":"problems/2503/","title":"Coming Soon","text":"<p> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author"},{"location":"problems/29/","title":"29. Divide Two Integers","text":"","tags":["Math","Bit Manipulation"]},{"location":"problems/29/#29-divide-two-integers","title":"29. Divide Two Integers","text":"<p>Medium</p>","tags":["Math","Bit Manipulation"]},{"location":"problems/29/#description","title":"Description","text":"<p>Given two integers <code>dividend</code> and <code>divisor</code>, divide two integers without using multiplication, division, and mod operator.</p> <p>The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.</p> <p>Return the quotient after dividing <code>dividend</code> by <code>divisor</code>.</p> <p>Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [\u22122<sup>31</sup>, 2<sup>31</sup> \u2212 1]. For this problem, if the quotient is strictly greater than 2<sup>31</sup> - 1, then return 2<sup>31</sup> - 1, and if the quotient is strictly less than -2<sup>31</sup>, then return -2<sup>31</sup>.</p> <p>Example 1:</p> <pre><code>Input: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\n</code></pre> <p>Example 2:</p> <pre><code>Input: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n</code></pre> <p>Constraints:</p> <ul> <li><code>-2</code><sup>31</sup><code>&lt;= dividend, divisor &lt;= 2</code><sup>31</sup><code>- 1</code></li> <li><code>divisor != 0</code></li> </ul>","tags":["Math","Bit Manipulation"]},{"location":"problems/29/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p>","tags":["Math","Bit Manipulation"]},{"location":"problems/29/#approach-simulation","title":"Approach: Simulation","text":"<p> Time complexity: \\(O(log \\times n)\\)</p> <p> Space complexity: \\(O(1)\\)</p>","tags":["Math","Bit Manipulation"]},{"location":"problems/29/#way-1","title":"Way 1","text":"<p>Algorithmic Way</p> <p>The time complexity of the algorithm is \\(O(log \\times n)\\) where n is the value of the dividend. This is because we use bit shifting to reduce the size of the dividend logarithmically.</p> <p>The space complexity of the algorithm is \\(O(1)\\). We use a fixed amount of extra space for variables regardless of the input size.</p> Python <pre><code>class Solution:\n    def divide(self, dividend: int, divisor: int) -&gt; int:\n        # Handle overflow case\n        if dividend == -2**31 and divisor == -1:\n            return 2**31 - 1\n        # Determine the sign of the result\n        sign = (dividend &lt; 0) != (divisor &lt; 0)\n        # Work with positive values for simplicity\n        dvd, dvs = abs(dividend), abs(divisor)\n        ans = 0     #quotient\n        hs = 31     # The highest bit for divisor to be shifted\n\n        # Find the highest bit where divisor can be shifted\n        while hs &gt;= 0 and (dvs &lt;&lt; hs) &gt; dvd:\n            hs -= 1\n        # Subtract shifted divisor from dividend\n        for i in range(hs, -1, -1):\n            if (dvs &lt;&lt; i) &lt;= dvd:\n                dvd -= (dvs &lt;&lt; i)\n                ans += (1 &lt;&lt; i)\n        # Apply the sign to the quotient\n        return -ans if sign else ans\n</code></pre> Bitwise Left Shift operator <code>&lt;&lt;</code> <p>In Python, a &lt;&lt; b is read as \"a left-shifted by b bits.\" It's a bitwise operator that shifts the binary representation of a to the left by b positions. This is equivalent to multiplying a by 2 raised to the power of b (i.e., a * 2**b). Zeroes are filled in from the right during the shift.</p> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Math","Bit Manipulation"]},{"location":"problems/3/","title":"3. Longest Substring Without Repeating Characters","text":"","tags":["Hash Table","String","Sliding Window"]},{"location":"problems/3/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<p>Medium</p>","tags":["Hash Table","String","Sliding Window"]},{"location":"problems/3/#description","title":"Description","text":"<p>Given a string <code>s</code>, find the length of the longest substring without duplicate characters.</p> <p>Example 1:</p> <pre><code>Input: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n</code></pre> <p>Example 2:</p> <pre><code>Input: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n</code></pre> <p>Example 3:</p> <pre><code>Input: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n</code></pre> <p>Constraints:</p> <ul> <li><code>0 &lt;= s.length &lt;= 5 * 104</code></li> <li><code>s consists of English letters, digits, symbols and spaces.</code></li> </ul>","tags":["Hash Table","String","Sliding Window"]},{"location":"problems/3/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p> Algorithm Implementation","tags":["Hash Table","String","Sliding Window"]},{"location":"problems/3/#sliding-window","title":"Sliding Window","text":"<p>1.We can keep tracking a current window, and use two pointer to apply the sliding window algorithms.</p> <p>2.We can expand the window to the right greedily as long as the character is not existent in the current window.</p> <p>3.Otherwise, we need to move the left pointer and erase the corresponding characters at left pointer out of the window until the current character at the right pointer is no longer in the window.</p> <p>4.If we don\u2019t move the left pointer (shrink the window), the substring is not valid no matter how we move the right pointer.</p> <p>The time complexity is \\(O(n)\\) as the left and right pointers both move towards the right and the space complexity is \\(O(n)\\) as we need a hash-set or dictionary to store the elements in the current window.</p>","tags":["Hash Table","String","Sliding Window"]},{"location":"problems/3/#approach-sliding-window-flexible-longest","title":"Approach: Sliding Window flexible longest","text":"<p> Time complexity: \\(O(n)\\)</p> <p> Space complexity: \\(O(1)\\)</p>","tags":["Hash Table","String","Sliding Window"]},{"location":"problems/3/#way-1-using-two-pointers-dictionary-hash-table","title":"Way 1: Using Two pointers + Dictionary (Hash Table)","text":"<p>Algorithm 1</p> <p>To solve this problem, we'll use a sliding window approach with a dictionary.</p> <p>We'll keep track of the characters we've seen and their count. We'll move the right pointer of our window, adding characters to the dictionary. If we find a repeating character, we'll move the left pointer to the right of the last occurrence of that character. We'll update the maximum length of the substring as we go.</p> <p>The time complexity of this solution is \\(O(n)\\), where \\(n\\) is the length of the input string.</p> Python <pre><code>class Solution:\n    def lengthOfLongestSubstring(self,s):\n        ans = 0\n        l = 0\n        n = len(s)\n        cnt = Counter() #window, a hastable of characters with their count(values)\n\n        for r in range(n):\n            cnt[s[r]]+=1 #add/increment the count of the incoming element\n\n            while cnt[s[r]]&gt;1:    #window condition is broken when the same character repeat i.e count of that element/character becomes greater than 1\n                cnt[s[l]]-=1      #remove outging element from left by decrementing its count by 1 in window(aka dictionary)\n                l+=1\n            w_len = r - l + 1\n            ans = max(ans,w_len)\n        return ans\n</code></pre>","tags":["Hash Table","String","Sliding Window"]},{"location":"problems/3/#way-2-using-set","title":"Way 2: Using Set","text":"<p>Algorithm 2</p> Python <pre><code>class Solution:\n    def lengthOfLongestSubstring(self, s: str) -&gt; int:\n        ans = 0\n        l = 0\n        n = len(s)\n        win = set()\n        for r in range(n):\n            while s[r] in win: #invalid window condition or window condition is broken\n                win.remove(s[l]) #remove the outgoing element\n                l+=1\n\n            win.add(s[r]) #add the incoming element\n            w_len = r - l + 1 #current window length\n            ans = max(ans,w_len)\n\n        return ans\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Hash Table","String","Sliding Window"]},{"location":"problems/374/","title":"374. Guess Number Higher or Lower","text":"","tags":["Binary Search","Interactive"]},{"location":"problems/374/#374-guess-number-higher-or-lower","title":"374. Guess Number Higher or Lower","text":"<p>Easy</p>","tags":["Binary Search","Interactive"]},{"location":"problems/374/#description","title":"Description","text":"<p>We are playing the Guess Game. The game is as follows:</p> <p>I pick a number from <code>1</code> to <code>n</code>. You have to guess which number I picked.</p> <p>Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.</p> <p>You call a pre-defined API <code>int guess(int num)</code>, which returns three possible results:</p> <ul> <li><code>-1</code>: Your guess is higher than the number I picked (i.e. <code>num &gt; pick</code>).</li> <li><code>1</code>: Your guess is lower than the number I picked (i.e. <code>num &lt; pick</code>).</li> <li><code>0</code>: your guess is equal to the number I picked (i.e. <code>num == pick</code>).</li> </ul> <p>Return the number that I picked.</p> <p>Example 1:</p> <pre><code>Input: n = 10, pick = 6\nOutput: 6\n</code></pre> <p>Example 2:</p> <pre><code>Input: n = 1, pick = 1\nOutput: 1\n</code></pre> <p>Example 3:</p> <pre><code>Input: n = 2, pick = 1\nOutput: 1\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 231 - 1</code></li> <li><code>1 &lt;= pick &lt;= n</code></li> </ul>","tags":["Binary Search","Interactive"]},{"location":"problems/374/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p>","tags":["Binary Search","Interactive"]},{"location":"problems/374/#approach-binary-search","title":"Approach: Binary Search","text":"<p> Time complexity: \\(O(\\log n)\\)</p> <p> Space complexity: \\(O(1)\\)</p>","tags":["Binary Search","Interactive"]},{"location":"problems/374/#way-1","title":"Way 1:","text":"<p>Algorithmic</p> <p>We perform a binary search in the interval \\([1,..n]\\), and find the first number that satisfies <code>guess(x) &lt;= 0</code>, which is the answer.</p> <p>The time complexity is \\(O(\\log n)\\), where \\(n\\) is the upper limit given in the problem. The space complexity is \\(O(1)\\)</p> Python <pre><code># The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num: int) -&gt; int:\n\nclass Solution:\n    def guessNumber(self, n: int) -&gt; int:\n        l , r = 1 , n\n\n        while l &lt; r:\n            mid = (l+r)//2\n\n            # Find the first guess number that is greater than or equal to the target number\n            if guess(mid) &lt;= 0:\n                r = mid\n            else:\n                l = mid + 1\n\n        return l\n</code></pre> equivalency <pre><code>...\nif guess(mid) == 0:\n    return mid\nelif guess(mid) == -1:\n    r = mid - 1\n...\n        ||\n        ||\n        ||\n...\nif guess(mid) &lt;= 0:\n    r = mid\n...\n</code></pre>","tags":["Binary Search","Interactive"]},{"location":"problems/374/#way-2","title":"Way 2:","text":"<p>Pythonic</p> Python <pre><code># The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num: int) -&gt; int:\n\nfrom bisect import *\nclass Solution:\n    def guessNumber(self, n: int) -&gt; int:\n        return bisect(range(1, n + 1), 0 , key = lambda x : -guess(x))\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Binary Search","Interactive"]},{"location":"problems/4/","title":"Coming Soon","text":"<p> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author"},{"location":"problems/40/","title":"Coming Soon","text":"Akhil Singh Chauhan                          Author"},{"location":"problems/407/","title":"407. Trapping Rain Water II","text":"","tags":["Array","Breadth-First Search","Heap (Priority Queue)","Matrix"]},{"location":"problems/407/#407-trapping-rain-water-ii","title":"407. Trapping Rain Water II","text":"<p>Hard</p>","tags":["Array","Breadth-First Search","Heap (Priority Queue)","Matrix"]},{"location":"problems/407/#description","title":"Description","text":"<p>Given an <code>m x n</code> integer matrix <code>heightMap</code> representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.</p> <p>Example 1:</p> <p></p> <pre><code>Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]\nOutput: 4\nExplanation: After the rain, water is trapped between the blocks.\nWe have two small ponds 1 and 3 units trapped.\nThe total volume of water trapped is 4.\n</code></pre> <p>Example 2:</p> <p></p> <pre><code>Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]\nOutput: 10\n</code></pre> <p>Constraints:</p> <ul> <li><code>m == heightMap.length</code></li> <li><code>n == heightMap[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 200</code></li> <li><code>0 &lt;= heightMap[i][j] &lt;= 2 * 104</code></li> </ul>","tags":["Array","Breadth-First Search","Heap (Priority Queue)","Matrix"]},{"location":"problems/407/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p>","tags":["Array","Breadth-First Search","Heap (Priority Queue)","Matrix"]},{"location":"problems/407/#approach-bfs-priority-queue-min-heap","title":"Approach: BFS + Priority Queue (Min Heap)","text":"<p> Time complexity: \\(O(mn \\log mn)\\)</p> <p> Space complexity: \\(O(mn)\\)</p>","tags":["Array","Breadth-First Search","Heap (Priority Queue)","Matrix"]},{"location":"problems/407/#way-1","title":"Way 1:","text":"<p>Algorithmic Way</p> <p>The problem requires finding the volume of water that can be trapped given a 2D elevation map.</p> <p>We use a min-heap \\(\\textit{pq}\\) to always process the lowest boundary first, which allows us to determine how much water can be trapped above it.</p> <p>We initialize the heap \\(\\textit{pq}\\) with all boundary cells and mark them as visited in set \\(\\textit{vis}\\). Then, we process each cell by popping from the heap, checking its neighbors, and calculating trapped water if applicable. The neighbors are pushed into the heap if they haven't been visited yet, and we update the maximum height seen so far to calculate water trapping correctly.</p> <p>The time complexity is \\(O(mn \\log mn)\\), where \\(n\\) is the number of rows and \\(m\\) is the number of columns in the heightMap array. Each cell is pushed and popped from the heap once, and heap operations take \\(O(\\log mn)\\) time.</p> <p>The space complexity is \\(O(mn)\\), for storing the visited \\(\\textit{vis}\\) set and the priority queue \\(\\textit{pq}\\), which can grow up to the size of all the cells in the grid.</p> Python <pre><code>class Solution:\n    def trapRainWater(self, heightMap: List[List[int]]) -&gt; int:\n        if not heightMap or not heightMap[0]:\n            return 0\n        m, n = len(heightMap), len(heightMap[0])\n        pq = []     #min heap\n        vis = set()\n        # Push all the boundary cells into the heap(aka priority queue)\n        for i in range(m):\n            heappush(pq, (heightMap[i][0], i, 0))\n            heappush(pq, (heightMap[i][n-1], i, n-1))\n            vis.add((i, 0))\n            vis.add((i, n-1))\n\n        for j in range(n):\n            heappush(pq, (heightMap[0][j], 0, j))\n            heappush(pq, (heightMap[m-1][j], m-1, j))\n            vis.add((0, j))\n            vis.add((m-1, j))\n\n        directions = [(1,0),(-1,0),(0,1),(0,-1)]\n        ans = 0      #water_trapped\n        max_height = 0\n        while pq:\n            h, i, j = heappop(pq)     # h - height\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 &lt;=ni &lt; m and 0 &lt;=nj &lt; n and (ni,nj) not in vis:\n                    vis.add((ni, nj))\n                    ans += max(0, h - heightMap[ni][nj])\n                    max_height = max(h, heightMap[ni][nj])\n                    heappush(pq, (max_height, ni, nj))\n        return ans\n</code></pre> equivalency <pre><code>...\nfor i in range(m):\n    heappush(pq, (heightMap[i][0], i, 0))\n    heappush(pq, (heightMap[i][n-1], i, n-1))\n    vis.add((i, 0))\n    vis.add((i, n-1))\n\nfor j in range(n):\n    heappush(pq, (heightMap[0][j], 0, j))\n    heappush(pq, (heightMap[m-1][j], m-1, j))\n    vis.add((0, j))\n    vis.add((m-1, j))\n...\n            ||\n            ||\n            ||\n...\nfor i in range(m):\n    for j in [0, n-1]:\n        heappush(pq, (heightMap[i][j], i, j))\n        vis.add((i, j))\n\nfor j in range(n):\n    for i in [0, m-1]:\n        heappush(pq, (heightMap[i][j], i, j))\n        vis.add((i, j))\n...\n</code></pre> <p>There could be many other ways or writing styles, but I prefer mine</p> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Array","Breadth-First Search","Heap (Priority Queue)","Matrix"]},{"location":"problems/42/","title":"42. Trapping Rain Water","text":"","tags":["Array","Two Pointers","Dynamic Programming","Stack","Monotonic Stack"]},{"location":"problems/42/#42-trapping-rain-water","title":"42. Trapping Rain Water","text":"<p>Hard</p>","tags":["Array","Two Pointers","Dynamic Programming","Stack","Monotonic Stack"]},{"location":"problems/42/#description","title":"Description","text":"<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p> <p>Example 1:</p> <p></p> <pre><code>Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.\n</code></pre> <p>Example 2:</p> <pre><code>Input: height = [4,2,0,3,2,5]\nOutput: 9\n</code></pre> <p>Constraints:</p> <ul> <li><code>n == height.length</code></li> <li><code>1 &lt;= n &lt;= 2 * 104</code></li> <li><code>0 &lt;= height[i] &lt;= 105</code></li> </ul>","tags":["Array","Two Pointers","Dynamic Programming","Stack","Monotonic Stack"]},{"location":"problems/42/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p>","tags":["Array","Two Pointers","Dynamic Programming","Stack","Monotonic Stack"]},{"location":"problems/42/#approach-two-pointers-dp","title":"Approach: Two Pointers + DP","text":"<p> Time complexity: \\(O(n)\\)</p> <p> Space complexity: \\(O(n)\\)</p>","tags":["Array","Two Pointers","Dynamic Programming","Stack","Monotonic Stack"]},{"location":"problems/42/#way-1","title":"Way 1","text":"<p>Algorithmic Way</p> <p>We define \\(L[i]\\) as the height of the highest bar to the left of and including the position at index \\(i\\), and \\(R[i]\\) as the height of the highest bar to the right of and including the position at index \\(i\\).</p> <p>Therefore, the amount of rainwater that can be trapped at index \\(i\\) is \\(min(L[i],R[i])-height[i]\\).</p> <p>We traverse the array to calculate \\(L[i]\\) and \\(R[i]\\), and the final answer is</p> \\[\\sum_{i=0}^{n-1} \\min(L[i], R[i]) - height[i]\\] <p>The time complexity is \\(O(n)\\), and the space complexity is \\(O(n)\\). Here, n is the length of the array.</p> Python <pre><code>class Solution:\n    def trap(self, height: List[int]) -&gt; int:\n        n = len(height)\n\n        #Intialization\n        L = [height[0]] +  [0]*(n-1)\n        R = [0]*(n-1) + [height[-1]]\n\n        #Traverse &amp; Compute\n        for i in range(1,n):\n            L[i] = max(l[i-1],height[i])\n            R[n-1-i] = max(r[n-i],height[n-1-i])\n\n        return sum(min(L[i],R[i]) - height[i] for i in range(n))\n</code></pre>","tags":["Array","Two Pointers","Dynamic Programming","Stack","Monotonic Stack"]},{"location":"problems/42/#way-2-same-appraoch-using-tilde-operator-easy-to-visulize-write","title":"Way 2: Same Appraoch Using Tilde(~) Operator, Easy to Visulize &amp; write","text":"Python Corner <p>In python <code>~i</code> is equivalent to <code>-1-i</code>.</p> <p>We can iterate over the list <code>height</code> from the end to the beginning.</p> <p><code>~i</code> is used to access elements from the end of the list r in reverse order.</p> <p><code>~(i - 1)</code> allows us to correctly reference the previous element in the list when iterating in reverse.</p> Python <pre><code>class Solution:\n    def trap(self, height: List[int]) -&gt; int:\n        n = len(height)\n\n        # Initialization\n        L = [height[0]] + [0] * (n - 1)\n        R = [0] * (n - 1) + [height[-1]]\n\n        # Traverse &amp; Compute\n        for i in range(1, n):\n            L[i] = max(l[i - 1], height[i])\n            R[~i] = max(r[~(i - 1)], height[~i])\n\n\n        return sum(min(L[i], R[i]) - height[i] for i in range(n))\n</code></pre>","tags":["Array","Two Pointers","Dynamic Programming","Stack","Monotonic Stack"]},{"location":"problems/42/#way-3","title":"Way 3","text":"<p>Pythonic</p> <p>Another way of writing using python built-in <code>zip</code> function.</p> Python <pre><code>class Solution:\n    def trap(self, height: List[int]) -&gt; int:\n        n = len(height)\n\n        left = [height[0]] * n\n        right = [height[-1]] * n\n\n        for i in range(1, n):\n            left[i] = max(left[i - 1], height[i])\n            right[n - i - 1] = max(right[n - i], height[n - i - 1])\n\n        return sum(min(l, r) - h for l, r, h in zip(left, right, height))\n</code></pre> <p>There could be many other solutions or approaches</p> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Array","Two Pointers","Dynamic Programming","Stack","Monotonic Stack"]},{"location":"problems/45/","title":"Coming Soon","text":"<p> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author"},{"location":"problems/5/","title":"Coming Soon","text":"Akhil Singh Chauhan                          Author"},{"location":"problems/52/","title":"52. N-Queens II","text":"","tags":["Backtracking"]},{"location":"problems/52/#52-n-queens-ii","title":"52. N-Queens II","text":"<p>Hard</p>","tags":["Backtracking"]},{"location":"problems/52/#description","title":"Description","text":"<p>The n-queens puzzle is the problem of placing \\(n\\) queens on an \\(n \\times n\\) chessboard such that no two queens attack each other.</p> <p>Given an integer \\(n\\), return the number of distinct solutions to the n-queens puzzle.</p> <p>Example 1:</p> <pre><code>Input: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown below\n</code></pre> <p></p> <p>Example 2:</p> <pre><code>Input: n = 1\nOutput: 1\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= n &lt;= 9</code></li> </ul>","tags":["Backtracking"]},{"location":"problems/52/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p>","tags":["Backtracking"]},{"location":"problems/52/#approach-backtracking","title":"Approach : Backtracking","text":"<p> Time complexity: \\(O(n!)\\)</p> <p> Space complexity: \\(O(n)\\)</p>","tags":["Backtracking"]},{"location":"problems/52/#way-1","title":"Way 1\ud83d\udc4b Please log in to view the solution","text":"<p>Algorithmic</p> <p>The problem requires us to find all distinct ways to place n queens on an \\(n \\times n\\) chessboard so that no two queens threaten each other.</p> <p>We use a backtracking depth-first search (DFS) approach to explore all possible placements of queens row by row.</p> <p>To efficiently check if a queen can be placed at position \\((i, j)\\), we keep track of columns, diagonals, and anti-diagonals that are already occupied by queens using three boolean arrays.</p> <p>For each column \\(j\\) in row \\(i\\), we calculate the diagonal index <code>(d_idx)</code> and anti-diagonal index <code>(ad_idx)</code>. If any of these positions are already marked as True in their respective arrays, we skip placing a queen there.</p> <p>If a queen can be placed, we mark the column, diagonal, and anti-diagonal as <code>True</code> and recursively attempt to place queens in the next row.</p> <p>After exploring all possibilities for the current row, we backtrack by marking the column, diagonal, and anti-diagonal as <code>False</code>, allowing other potential placements to be explored.</p> <p>The base case for our DFS function is when <code>i equals n</code>, which means we have successfully placed \\(n\\) queens without conflicts, and we increment the answer counter.</p> Python <pre><code>class Solution:\n    def totalNQueens(self, n: int) -&gt; int:\n        def dfs(i: int) -&gt; None:\n            nonlocal ans\n            if i == n:\n                ans += 1\n                return\n\n            for j in range(n):\n                d_idx, ad_idx = i + j , j - i + n - 1\n                if cols[j] or diag[d_idx] or a_diag[ad_idx]:\n                    continue\n                cols[j] = diag[d_idx] = a_diag[ad_idx] = True\n                dfs(i + 1)\n                cols[j] = diag[d_idx] = a_diag[ad_idx] = False\n\n        #initialization\n        ans = 0\n        cols = [False] * n\n        diag = [False] * (2 * n - 1)\n        a_diag = [False] * (2 * n - 1)\n\n\n        dfs(0) #dfs start\n        return ans\n</code></pre> <p>Detailed Complexity Discussion</p> <p>The time complexity of this solution is \\(O(n!)\\) in the worst case. This is because we attempt to place a queen in each column of each row, and once a queen is placed, we reduce the problem size by one row. In the best case, where conflicts occur early, it can be less than \\(O(n!)\\). However, on average, the algorithm explores a significant portion of the n! possible permutations of queen placements.</p> <p>The space complexity is \\(O(n)\\) due to the storage required for the three boolean arrays (cols, diag, a_diag) that track the columns, diagonals, and anti-diagonals respectively. These arrays have sizes \\(n\\), \\(2n-1\\), and \\(2n-1\\), all of which are proportional to \\(n\\). Additionally, the recursion stack can go up to a depth of \\(n\\), contributing to the space complexity.</p> <p></p> <p> <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Backtracking"]},{"location":"problems/6/","title":"Coming Soon","text":"Akhil Singh Chauhan                          Author"},{"location":"problems/7/","title":"Coming Soon","text":"Akhil Singh Chauhan                          Author"},{"location":"problems/703/","title":"703. Kth Largest Element in a Stream","text":"","tags":["Heap (Priority Queue)","Tree","Design","Binary Search Tree","Binary Tree","Data Stream"]},{"location":"problems/703/#703-kth-largest-element-in-a-stream","title":"703. Kth Largest Element in a Stream","text":"<p>Easy</p>","tags":["Heap (Priority Queue)","Tree","Design","Binary Search Tree","Binary Tree","Data Stream"]},{"location":"problems/703/#description","title":"Description","text":"<p>You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.</p> <p>You are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores.</p> <p>Implement the <code>KthLargest</code> class:</p> <p><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer k and the stream of test scores <code>nums</code>. <code>int add(int val)</code> Adds a new test score val to the stream and returns the element representing the \\(k^{th}\\) largest element in the pool of test scores so far.</p> <p>Example 1:</p> <pre><code>Input:\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n\nOutput: [null, 4, 5, 5, 8, 8]\n\nExplanation:\n\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3); // return 4\nkthLargest.add(5); // return 5\nkthLargest.add(10); // return 5\nkthLargest.add(9); // return 8\nkthLargest.add(4); // return 8\n</code></pre> <p>Example 2:</p> <pre><code>Input:\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\"]\n[[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]\n\nOutput: [null, 7, 7, 7, 8]\n\nExplanation:\n\nKthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]);\nkthLargest.add(2); // return 7\nkthLargest.add(10); // return 7\nkthLargest.add(9); // return 7\nkthLargest.add(9); // return 8\n</code></pre> <p>Constraints:</p> <ul> <li><code>0 &lt;= nums.length &lt;= 104</code></li> <li><code>1 &lt;= k &lt;= nums.length + 1</code></li> <li><code>-104 &lt;= nums[i] &lt;= 104</code></li> <li><code>-104 &lt;= val &lt;= 104</code></li> <li><code>At most 104 calls will be made to add.</code></li> </ul>","tags":["Heap (Priority Queue)","Tree","Design","Binary Search Tree","Binary Tree","Data Stream"]},{"location":"problems/703/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p>","tags":["Heap (Priority Queue)","Tree","Design","Binary Search Tree","Binary Tree","Data Stream"]},{"location":"problems/703/#approach-priority-queue-min-heap","title":"Approach: Priority Queue (Min Heap)","text":"<p> Time complexity: \\(O(n \\times \\log k)\\)</p> <p> Space complexity: \\(O(k)\\)</p>","tags":["Heap (Priority Queue)","Tree","Design","Binary Search Tree","Binary Tree","Data Stream"]},{"location":"problems/703/#way-1","title":"Way 1:","text":"<p>Algorithmic</p> <p>We maintain a priority queue \\(\\textit{pq}\\) (min heap).</p> <p>Initially, we add the elements of the array \\(\\textit{nums}\\) to \\(\\textit{pq}\\) one by one, ensuring that the size of \\(\\textit{pq}\\) does not exceed \\(k\\). The time complexity is \\(O(n \\times \\log k)\\).</p> <p>Each time a new element is added, if the size of \\(\\textit{pq}\\) exceeds \\(k\\), we pop the top element of the heap to ensure that the size of \\(\\textit{pq}\\) is \\(k\\). The time complexity is \\(O(\\log k)\\).</p> <p>In this way, the elements in \\(\\textit{pq}\\) are the largest \\(k\\) elements in the array \\(\\textit{nums}\\), and the top element of the heap is the \\(k^{th}\\) largest element.</p> <p>The space complexity is \\(O(k)\\).</p> Python <pre><code>class KthLargest:\n    def __init__(self, k: int, nums: List[int]):\n        self.k = k\n        self.pq = []    # min heap\n        for num in nums:\n            self.add(num)\n\n    def add(self, val: int) -&gt; int:\n        heappush( self.pq, val)\n        if len(self.pq) &gt; self.k:\n            heappop(self.pq)\n        return self.pq[0]\n\n\n# Your KthLargest object will be instantiated and called as such:\n# obj = KthLargest(k, nums)\n# param_1 = obj.add(val)\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Heap (Priority Queue)","Tree","Design","Binary Search Tree","Binary Tree","Data Stream"]},{"location":"problems/74/","title":"74. Search a 2D Matrix","text":"","tags":["Array","Binary Search","Matrix"]},{"location":"problems/74/#74-search-a-2d-matrix","title":"74. Search a 2D Matrix","text":"<p>Medium</p>","tags":["Array","Binary Search","Matrix"]},{"location":"problems/74/#description","title":"Description","text":"<p>You are given an m x n integer matrix matrix with the following two properties:</p> <ul> <li>Each row is sorted in non-decreasing order.</li> <li>The first integer of each row is greater than the last integer of the previous row.</li> <li>Given an integer target, return true if target is in matrix or false otherwise.</li> </ul> <p>You must write a solution in <code>O(log(m * n))</code> time complexity.</p> <p>Example 1:</p> <pre><code>Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3\nOutput: true\n</code></pre> <p></p> <p>Example 2:</p> <pre><code>Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13\nOutput: false\n</code></pre> <p></p> <p>Constraints:</p> <ul> <li><code>m == matrix.length</code></li> <li><code>n == matrix[i].length</code></li> <li><code>1 &lt;= m, n &lt;= 100</code></li> <li><code>-104 &lt;= matrix[i][j], target &lt;= 104</code></li> </ul>","tags":["Array","Binary Search","Matrix"]},{"location":"problems/74/#solutions","title":"Solutions","text":"<p> <p>Video Solution Coming Soon</p>","tags":["Array","Binary Search","Matrix"]},{"location":"problems/74/#approach-optimised-binary-search-in-a-2d-matrix","title":"Approach : (Optimised) Binary Search in a 2D Matrix","text":"<p> Time complexity: \\(O(log(m \\times n))\\)</p> <p> Space complexity: \\(O(1)\\)</p>","tags":["Array","Binary Search","Matrix"]},{"location":"problems/74/#way-1","title":"Way 1","text":"<p>Algorithmic</p> <p>The given matrix has special properties where each row is sorted and the first element of each row is greater than the last element of the previous row.</p> <p>This means that matrix is sorted if you go from top left to bottom right, row by row. So we can treat this 2D matrix as a sorted 1D array and use Binary Search to find the target.</p> <p>The key is to convert the middle index of binary search into corresponding row and column indices of the matrix.</p> <p>To convert a 1D index to 2D indices, we can use:</p> <ul> <li> <p>row = index / number of columns</p> </li> <li> <p>column = index % number of columns</p> </li> </ul> <p>The time complexity of this solution is O(log(m * n)) as we are performing binary search on m * n elements.</p> Python <pre><code>class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        #Get Dimensions\n        m , n = len(matrix),len(matrix[0])\n\n        #Initialize BS boundaries\n        left ,right = 0 , m*n\n\n        #Start Search\n        while left&lt;right:\n            #crucial steps\n            mid = (left+right)//2\n\n            # Convert 1D index to 2D indices\n            i , j = mid//n, mid % n     #To get the row and column of the midpoint in the matrix\n\n            # Compare current element with target\n            if matrix[i][j]==target:\n                return True\n\n            if matrix[i][j]&lt;target:\n                left= mid+1\n            else:\n                right= mid\n        return False\n</code></pre> equivalency <pre><code>mid = (left+right) // 2\n        ||\n        ||\n        ||\nmid = (left+right) &gt;&gt; 1\n</code></pre>","tags":["Array","Binary Search","Matrix"]},{"location":"problems/74/#way-2","title":"Way 2","text":"<p>Another way of writing Binary Search</p> <p>We can logically unfold the two-dimensional matrix and then perform binary search. The time complexity is O (log(m x n)), where m and n are the number of rows and columns of the matrix, respectively. The space complexity is O (1).</p> PythonKotlin <pre><code>class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        m , n = len(matrix), len(matrix[0])\n\n        left, right = 0, m*n-1\n\n        while left&lt;=right:\n            mid = (left+right)&gt;&gt;1\n\n            i, j = divmod(mid,n)                   # note: divide column count\n\n            if matrix[i][j]==target:\n                return True\n\n            elif matrix[i][j]&lt;target:\n                left= mid+1\n            else:\n                right= mid-1\n        return False\n</code></pre> <pre><code>class Solution {\n    fun searchMatrix(matrix: Array&lt;IntArray&gt;, target: Int): Boolean {\n        if (matrix.isEmpty() || matrix[0].isEmpty()) return false\n        val m = matrix.size\n        val n = matrix[0].size\n        var left = 0\n        var right = m * n - 1\n        while (left &lt;= right) {\n            val mid = left + (right - left) / 2\n            val midValue = matrix[mid / n][mid % n]\n            when {\n                midValue == target -&gt; return true\n                midValue &lt; target -&gt; left = mid + 1\n                else -&gt; right = mid - 1\n            }\n        }\n        return false\n    }\n}\n</code></pre> equivalency <ul> <li>To get the row and column of the midpoint in the matrix, we use the <code>divmod</code> function with mid and n. The <code>divmod</code> function takes two numbers and returns a pair of numbers (a tuple) consisting of their quotient and remainder.</li> </ul> <pre><code>i, j = divmod(mid,n)\n        ||\n        ||\n        ||\ni, j = mid//n, mid%n\n</code></pre>","tags":["Array","Binary Search","Matrix"]},{"location":"problems/74/#approach-search-from-the-bottom-left-or-top-right","title":"Approach : Search from the Bottom Left or Top Right","text":"<p> Time complexity: \\(O(m + n))\\)</p> <p> Space complexity: \\(O(1)\\)</p> <p>Algorithm2 for general matrix</p> <p>Here, we start searching from the bottom left corner and move towards the top right direction. We compare the current element matrix[row][col] with target:</p> <ul> <li>If matrix [row][col] = target, we have found the target value and return true.</li> <li>If matrix [row][col] &gt; target, all elements to the right of the current position in this row are greater than target, so we should move the pointer row upwards/left, i.e., row = row \u2014 1.</li> <li>If matrix[row][col] &lt; target, all elements above the current position in this column are less than target, so we should move the pointer col to the right, i.e., col = col+ 1.</li> <li>If we still cant find target after the search, return false.</li> </ul> <p>The time complexity is O(m + n), where m and n are the number of rows and columns of the matrix, respectively. The space complexity is O (1).</p> Python <pre><code>class Solution:\ndef searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n    if not matrix or not matrix[0]:\n        return False\n\n    m , n = len(matrix),len(matrix[0])\n\n    row , col = m-1,0\n    while row&gt;=0 and col&lt;n:\n        if matrix[row][col] == target:\n            return True\n        elif matrix[row][col]&gt;target:\n            row-=1\n        else: #matrix[row][col]&lt;target\n            col+=1\n\n    return False\n</code></pre>","tags":["Array","Binary Search","Matrix"]},{"location":"problems/74/#approach-1d-binary-search","title":"Approach : 1D-Binary Search\ud83d\udc4b Please log in to view the solution","text":"<p> Time complexity: \\(O(m \\log(n))\\)</p> <p> Space complexity: \\(O(1)\\)</p> <p>Algorithm3</p> <ul> <li>Applicable to searching target in any 2D matrix</li> </ul> Python <pre><code>class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool:\n        def BinarySearch(arr, target) -&gt; bool:\n            l , r = 0, len(arr)\n            while l&lt;r:\n                mid = (l+r)//2\n                if arr[mid]&gt;target:\n                    r=mid\n                elif arr[mid]&lt;target:\n                    l = mid+1\n                else:\n                    return True\n            return False\n\n        for arr in matrix:\n            if BinarySearch(arr,target):\n                return True\n\n        return False\n</code></pre> <p></p> <p> <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Array","Binary Search","Matrix"]},{"location":"problems/746/","title":"746. Min Cost Climbing Stairs","text":"","tags":["Array","Dynamic Programming"]},{"location":"problems/746/#746-min-cost-climbing-stairs","title":"746. Min Cost Climbing Stairs","text":"<p>Easy</p>","tags":["Array","Dynamic Programming"]},{"location":"problems/746/#description","title":"Description","text":"<p>You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.</p> <p>You can either start from the step with index 0, or the step with index 1.</p> <p>Return the minimum cost to reach the top of the floor.</p> <p>Example 1:</p> <pre><code>Input: cost = [10,15,20]\nOutput: 15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n</code></pre> <p>Example 2:</p> <pre><code>Input: cost = [1,100,1,1,1,100,1,1,100,1]\nOutput: 6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.\n</code></pre> <p>Constraints:</p> <ul> <li><code>2 &lt;= cost.length &lt;= 1000</code></li> <li><code>0 &lt;= cost[i] &lt;= 999</code></li> </ul>","tags":["Array","Dynamic Programming"]},{"location":"problems/746/#solutions","title":"Solutions","text":"<p>","tags":["Array","Dynamic Programming"]},{"location":"problems/746/#approach-functional-relationship","title":"Approach: Functional Relationship","text":"<p> Time complexity: \\(O(n)\\)</p> <p> Space complexity: \\(O(n)\\)</p>","tags":["Array","Dynamic Programming"]},{"location":"problems/746/#way-1","title":"Way 1:","text":"<p>Top Down DP via inbuilt library</p> <p>We define <code>f(i)</code> as the minimum cost required to reach the <code>i-th</code> step,</p> <p>Initially <code>f(0) = f(1) = 0</code>. The answer is <code>f(n)</code>.</p> <p>When <code>i \u2265 2</code>, we can directly reach the ith step from the <code>(i - 1)th</code> step using 1 step, or reach the ith step from the <code>(i - 2)th</code> step using 2 steps. Therefore, we have the state transition equation:   <code>f(i) = min(f(i - 1) + cost[i - 1], f(i - 2) + cost[i - 2])</code></p> <p>The final answer is <code>f(n)</code>.</p> <p>The time complexity is <code>O(n)</code>, and the space complexity is <code>O(n)</code>. Here, <code>n</code> is the length of the cost array.</p> Python <pre><code>class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:\n        n = len(cost)\n        @cache\n        def f(i):\n            if i==0:\n                return 0\n            if i==1:\n                return 0\n            return min(cost[i-1]+f(i-1), cost[i-2]+f(i-2))\n        return f(n)\n</code></pre> Top Down DP(Recursion+Memoization) Python <pre><code>class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:\n        n = len(cost)\n        def f(i,nb={}):\n            if i==0:\n                return 0\n            if i==1:\n                return 0\n\n            if i in nb:\n                return nb[i]\n\n            nb[i] = min(cost[i-1]+f(i-1), cost[i-2]+f(i-2))\n\n            return nb[i]\n\n        return f(n)\n</code></pre>","tags":["Array","Dynamic Programming"]},{"location":"problems/746/#way-2","title":"Way 2:","text":"<p> Time complexity: O(n)</p> <p> Space complexity: O(1)</p> <p>No-memory DP</p> <ul> <li>We notice that f(i) in the state transition equation is only related to f(i \u2014 1) and f(i - 2)</li> <li>Therefore, we can use two variables f0 and f1 to alternately record the values of f(i - 2) and f(i - 1), which optimizes the space complexity to O(1).</li> </ul> Python <pre><code>class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:\n        #Inital states\n        n = len(cost)\n        f0 , f1 = 0 , 0\n        for i in range(2,n+1):\n            fi = min(f1+cost[i-1], f0+cost[i-2])\n            f0 , f1 = f1 , fi\n        return fi\n</code></pre> Bottom Up DP- Tabulation Python <pre><code>class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:\n        #Inital states\n        n = len(cost)\n        dp = [0,0]+[0]*(n-1)\n\n        for i in range(2,n+1):\n            dp[i] = min(cost[i-1]+dp[i-1],cost[i-2]+dp[i-2])\n\n        return dp[n]\n</code></pre> <p></p> <p> \ud83d\udc4b Please log in to view the solution <p>Access to detailed solutions requires a login. Already have an account?</p> Log In <p>Don't have an account yet?</p> Sign Up <p></p> Akhil Singh Chauhan                          Author","tags":["Array","Dynamic Programming"]}]}